/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_NeuralParticleSystem_index_ts"],{

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css":
/*!*****************************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"NeuralParticleSystem_container__JUvux\",\"active\":\"NeuralParticleSystem_active__R988f\",\"green\":\"NeuralParticleSystem_green__LgrW2\",\"blue\":\"NeuralParticleSystem_blue__5N816\",\"purple\":\"NeuralParticleSystem_purple__pA7yk\",\"red\":\"NeuralParticleSystem_red__r8wNa\",\"cyan\":\"NeuralParticleSystem_cyan__VJwMX\",\"multi\":\"NeuralParticleSystem_multi__xJcce\",\"canvas\":\"NeuralParticleSystem_canvas__GZ2mZ\",\"matrixCanvas\":\"NeuralParticleSystem_matrixCanvas__mba2Y\",\"dataCanvas\":\"NeuralParticleSystem_dataCanvas__t7Flg\",\"scanlines\":\"NeuralParticleSystem_scanlines__gwL0L\",\"flicker\":\"NeuralParticleSystem_flicker__mWrFO\",\"subtlePulse\":\"NeuralParticleSystem_subtlePulse__Y_j3M\"};\n    if(true) {\n      // 1745581533032\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"9a446f8f49d3\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL05ldXJhbFBhcnRpY2xlU3lzdGVtLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQWlJLGNBQWMsc0RBQXNEO0FBQ25PLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTmV1cmFsUGFydGljbGVTeXN0ZW0vTmV1cmFsUGFydGljbGVTeXN0ZW0ubW9kdWxlLmNzcz9mNTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJjb250YWluZXJcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2NvbnRhaW5lcl9fSlV2dXhcIixcImFjdGl2ZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fYWN0aXZlX19SOTg4ZlwiLFwiZ3JlZW5cIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2dyZWVuX19MZ3JXMlwiLFwiYmx1ZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fYmx1ZV9fNU44MTZcIixcInB1cnBsZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fcHVycGxlX19wQTd5a1wiLFwicmVkXCI6XCJOZXVyYWxQYXJ0aWNsZVN5c3RlbV9yZWRfX3I4d05hXCIsXCJjeWFuXCI6XCJOZXVyYWxQYXJ0aWNsZVN5c3RlbV9jeWFuX19WSndNWFwiLFwibXVsdGlcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX211bHRpX194SmNjZVwiLFwiY2FudmFzXCI6XCJOZXVyYWxQYXJ0aWNsZVN5c3RlbV9jYW52YXNfX0daMm1aXCIsXCJtYXRyaXhDYW52YXNcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX21hdHJpeENhbnZhc19fbWJhMllcIixcImRhdGFDYW52YXNcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2RhdGFDYW52YXNfX3Q3RmxnXCIsXCJzY2FubGluZXNcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX3NjYW5saW5lc19fZ3dMMExcIixcImZsaWNrZXJcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2ZsaWNrZXJfX21XckZPXCIsXCJzdWJ0bGVQdWxzZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fc3VidGxlUHVsc2VfX1lfajNNXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NDU1ODE1MzMwMzJcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvY2svTGFuZGluZ1Byb3NwZXJhL3Byb3NwZXJhLW5leHRqcy9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCI5YTQ0NmY4ZjQ5ZDNcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/__barrel_optimize__?names=useCallback,useEffect,useRef!=!./node_modules/next/dist/compiled/react/index.js":
/*!*****************************************************************************************************************!*\
  !*** __barrel_optimize__?names=useCallback,useEffect,useRef!=!./node_modules/next/dist/compiled/react/index.js ***!
  \*****************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/react/index.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS9fX2JhcnJlbF9vcHRpbWl6ZV9fP25hbWVzPXVzZUNhbGxiYWNrLHVzZUVmZmVjdCx1c2VSZWYhPSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQWtCO0FBQ25EO0FBQ0EsNENBQTRDLE1BQWtCO0FBQzlEO0FBQ0E7QUFDQSxpRkFBaUYsU0FBcUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFrQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9pbmRleC5qcz8yYWE1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxja1xcXFxMYW5kaW5nUHJvc3BlcmFcXFxccHJvc3BlcmEtbmV4dGpzXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY29tcGlsZWRcXFxccmVhY3RcXFxcaW5kZXguanNcIlxuXG47XG4gICAgLy8gV3JhcHBlZCBpbiBhbiBJSUZFIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ2xvYmFsIHNjb3BlXG4gICAgO1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIExlZ2FjeSBDU1MgaW1wbGVtZW50YXRpb25zIHdpbGwgYGV2YWxgIGJyb3dzZXIgY29kZSBpbiBhIE5vZGUuanMgY29udGV4dFxuICAgICAgICAvLyB0byBleHRyYWN0IENTUy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBuZWVkIHRvIGNoZWNrIHdlJ3JlIGluIGFcbiAgICAgICAgLy8gYnJvd3NlciBjb250ZXh0IGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAvLyBBTVAgLyBOby1KUyBtb2RlIGRvZXMgbm90IGluamVjdCB0aGVzZSBoZWxwZXJzOlxuICAgICAgICAgICAgJyRSZWZyZXNoSGVscGVycyQnIGluIHNlbGYpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX193ZWJwYWNrX21vZHVsZV9fIGlzIGdsb2JhbFxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFeHBvcnRzID0gX193ZWJwYWNrX21vZHVsZV9fLmV4cG9ydHM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIF9fd2VicGFja19tb2R1bGVfXyBpcyBnbG9iYWxcbiAgICAgICAgICAgIHZhciBwcmV2U2lnbmF0dXJlID0gKF9iID0gKF9hID0gX193ZWJwYWNrX21vZHVsZV9fLmhvdC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldlNpZ25hdHVyZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGhhcHBlbiBpbiBNYWluVGVtcGxhdGUgYmVjYXVzZSB0aGUgZXhwb3J0cyBtaXNtYXRjaCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyB0ZW1wbGF0aW5nIGFuZCBleGVjdXRpb24uXG4gICAgICAgICAgICBzZWxmLiRSZWZyZXNoSGVscGVycyQucmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoKGN1cnJlbnRFeHBvcnRzLCBfX3dlYnBhY2tfbW9kdWxlX18uaWQpO1xuICAgICAgICAgICAgLy8gQSBtb2R1bGUgY2FuIGJlIGFjY2VwdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGV4cG9ydHMsIGUuZy4gd2hlblxuICAgICAgICAgICAgLy8gaXQgaXMgYSBSZWZyZXNoIEJvdW5kYXJ5LlxuICAgICAgICAgICAgaWYgKHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5pc1JlYWN0UmVmcmVzaEJvdW5kYXJ5KGN1cnJlbnRFeHBvcnRzKSkge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHByZXZpb3VzIGV4cG9ydHMgc2lnbmF0dXJlIG9uIHVwZGF0ZSBzbyB3ZSBjYW4gY29tcGFyZSB0aGUgYm91bmRhcnlcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmVzLiBXZSBhdm9pZCBzYXZpbmcgZXhwb3J0cyB0aGVtc2VsdmVzIHNpbmNlIGl0IGNhdXNlcyBtZW1vcnkgbGVha3MgKGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzUzNzk3KVxuICAgICAgICAgICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnByZXZTaWduYXR1cmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kUmVmcmVzaEhlbHBlcnMkLmdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZShjdXJyZW50RXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVW5jb25kaXRpb25hbGx5IGFjY2VwdCBhbiB1cGRhdGUgdG8gdGhpcyBtb2R1bGUsIHdlJ2xsIGNoZWNrIGlmIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBzdGlsbCBhIFJlZnJlc2ggQm91bmRhcnkgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbXBvcnRNZXRhIGlzIHJlcGxhY2VkIGluIHRoZSBsb2FkZXJcbiAgICAgICAgICAgICAgICBpbXBvcnQubWV0YS53ZWJwYWNrSG90LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmllbGQgaXMgc2V0IHdoZW4gdGhlIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBtb2R1bGUgd2FzIGFcbiAgICAgICAgICAgICAgICAvLyBSZWZyZXNoIEJvdW5kYXJ5LCBsZXR0aW5nIHVzIGtub3cgd2UgbmVlZCB0byBjaGVjayBmb3IgaW52YWxpZGF0aW9uIG9yXG4gICAgICAgICAgICAgICAgLy8gZW5xdWV1ZSBhbiB1cGRhdGUuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaWduYXR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBib3VuZGFyeSBjYW4gYmVjb21lIGluZWxpZ2libGUgaWYgaXRzIGV4cG9ydHMgYXJlIGluY29tcGF0aWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBleHBvcnRzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IGFkZC9yZW1vdmUvY2hhbmdlIGV4cG9ydHMsIHdlJ2xsIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtZXhlY3V0ZSB0aGUgaW1wb3J0aW5nIG1vZHVsZXMsIGFuZCBmb3JjZSB0aG9zZSBjb21wb25lbnRzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLXJlbmRlci4gU2ltaWxhcmx5LCBpZiB5b3UgY29udmVydCBhIGNsYXNzIGNvbXBvbmVudCB0byBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLCB3ZSB3YW50IHRvIGludmFsaWRhdGUgdGhlIGJvdW5kYXJ5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi4kUmVmcmVzaEhlbHBlcnMkLnNob3VsZEludmFsaWRhdGVSZWFjdFJlZnJlc2hCb3VuZGFyeShwcmV2U2lnbmF0dXJlLCBzZWxmLiRSZWZyZXNoSGVscGVycyQuZ2V0UmVmcmVzaEJvdW5kYXJ5U2lnbmF0dXJlKGN1cnJlbnRFeHBvcnRzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kUmVmcmVzaEhlbHBlcnMkLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBqdXN0IGV4ZWN1dGVkIHRoZSBjb2RlIGZvciB0aGUgbW9kdWxlLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV3IGV4cG9ydHMgbWFkZSBpdCBpbmVsaWdpYmxlIGZvciBiZWluZyBhIGJvdW5kYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgY2FzZSB3aGVuIHdlIHdlcmUgX3ByZXZpb3VzbHlfIGEgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhbHJlYWR5IGFjY2VwdGVkIHRoaXMgdXBkYXRlIChhY2NpZGVudGFsIHNpZGUgZWZmZWN0KS5cbiAgICAgICAgICAgICAgICB2YXIgaXNOb0xvbmdlckFCb3VuZGFyeSA9IHByZXZTaWduYXR1cmUgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9Mb25nZXJBQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgX193ZWJwYWNrX21vZHVsZV9fLmhvdC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/__barrel_optimize__?names=useCallback,useEffect,useRef!=!./node_modules/next/dist/compiled/react/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/__barrel_optimize__?names=useCallback,useRef!=!./node_modules/next/dist/compiled/react/index.js":
/*!*******************************************************************************************************!*\
  !*** __barrel_optimize__?names=useCallback,useRef!=!./node_modules/next/dist/compiled/react/index.js ***!
  \*******************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/react/index.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS9fX2JhcnJlbF9vcHRpbWl6ZV9fP25hbWVzPXVzZUNhbGxiYWNrLHVzZVJlZiE9IS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsTUFBa0I7QUFDbkQ7QUFDQSw0Q0FBNEMsTUFBa0I7QUFDOUQ7QUFDQTtBQUNBLGlGQUFpRixTQUFxQjtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQWtCO0FBQ2xDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2luZGV4LmpzP2U1ZWMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIkM6XFxcXFVzZXJzXFxcXGNrXFxcXExhbmRpbmdQcm9zcGVyYVxcXFxwcm9zcGVyYS1uZXh0anNcXFxcbm9kZV9tb2R1bGVzXFxcXG5leHRcXFxcZGlzdFxcXFxjb21waWxlZFxcXFxyZWFjdFxcXFxpbmRleC5qc1wiXG5cbjtcbiAgICAvLyBXcmFwcGVkIGluIGFuIElJRkUgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBnbG9iYWwgc2NvcGVcbiAgICA7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gTGVnYWN5IENTUyBpbXBsZW1lbnRhdGlvbnMgd2lsbCBgZXZhbGAgYnJvd3NlciBjb2RlIGluIGEgTm9kZS5qcyBjb250ZXh0XG4gICAgICAgIC8vIHRvIGV4dHJhY3QgQ1NTLiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHdlIG5lZWQgdG8gY2hlY2sgd2UncmUgaW4gYVxuICAgICAgICAvLyBicm93c2VyIGNvbnRleHQgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIC8vIEFNUCAvIE5vLUpTIG1vZGUgZG9lcyBub3QgaW5qZWN0IHRoZXNlIGhlbHBlcnM6XG4gICAgICAgICAgICAnJFJlZnJlc2hIZWxwZXJzJCcgaW4gc2VsZikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBfX3dlYnBhY2tfbW9kdWxlX18gaXMgZ2xvYmFsXG4gICAgICAgICAgICB2YXIgY3VycmVudEV4cG9ydHMgPSBfX3dlYnBhY2tfbW9kdWxlX18uZXhwb3J0cztcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX193ZWJwYWNrX21vZHVsZV9fIGlzIGdsb2JhbFxuICAgICAgICAgICAgdmFyIHByZXZTaWduYXR1cmUgPSAoX2IgPSAoX2EgPSBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2U2lnbmF0dXJlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgLy8gVGhpcyBjYW5ub3QgaGFwcGVuIGluIE1haW5UZW1wbGF0ZSBiZWNhdXNlIHRoZSBleHBvcnRzIG1pc21hdGNoIGJldHdlZW5cbiAgICAgICAgICAgIC8vIHRlbXBsYXRpbmcgYW5kIGV4ZWN1dGlvbi5cbiAgICAgICAgICAgIHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5yZWdpc3RlckV4cG9ydHNGb3JSZWFjdFJlZnJlc2goY3VycmVudEV4cG9ydHMsIF9fd2VicGFja19tb2R1bGVfXy5pZCk7XG4gICAgICAgICAgICAvLyBBIG1vZHVsZSBjYW4gYmUgYWNjZXB0ZWQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgZXhwb3J0cywgZS5nLiB3aGVuXG4gICAgICAgICAgICAvLyBpdCBpcyBhIFJlZnJlc2ggQm91bmRhcnkuXG4gICAgICAgICAgICBpZiAoc2VsZi4kUmVmcmVzaEhlbHBlcnMkLmlzUmVhY3RSZWZyZXNoQm91bmRhcnkoY3VycmVudEV4cG9ydHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgZXhwb3J0cyBzaWduYXR1cmUgb24gdXBkYXRlIHNvIHdlIGNhbiBjb21wYXJlIHRoZSBib3VuZGFyeVxuICAgICAgICAgICAgICAgIC8vIHNpZ25hdHVyZXMuIFdlIGF2b2lkIHNhdmluZyBleHBvcnRzIHRoZW1zZWx2ZXMgc2luY2UgaXQgY2F1c2VzIG1lbW9yeSBsZWFrcyAoaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL3B1bGwvNTM3OTcpXG4gICAgICAgICAgICAgICAgX193ZWJwYWNrX21vZHVsZV9fLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJldlNpZ25hdHVyZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiRSZWZyZXNoSGVscGVycyQuZ2V0UmVmcmVzaEJvdW5kYXJ5U2lnbmF0dXJlKGN1cnJlbnRFeHBvcnRzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBVbmNvbmRpdGlvbmFsbHkgYWNjZXB0IGFuIHVwZGF0ZSB0byB0aGlzIG1vZHVsZSwgd2UnbGwgY2hlY2sgaWYgaXQnc1xuICAgICAgICAgICAgICAgIC8vIHN0aWxsIGEgUmVmcmVzaCBCb3VuZGFyeSBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIGltcG9ydE1ldGEgaXMgcmVwbGFjZWQgaW4gdGhlIGxvYWRlclxuICAgICAgICAgICAgICAgIGltcG9ydC5tZXRhLndlYnBhY2tIb3QuYWNjZXB0KCk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyBzZXQgd2hlbiB0aGUgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGlzIG1vZHVsZSB3YXMgYVxuICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggQm91bmRhcnksIGxldHRpbmcgdXMga25vdyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpbnZhbGlkYXRpb24gb3JcbiAgICAgICAgICAgICAgICAvLyBlbnF1ZXVlIGFuIHVwZGF0ZS5cbiAgICAgICAgICAgICAgICBpZiAocHJldlNpZ25hdHVyZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGJvdW5kYXJ5IGNhbiBiZWNvbWUgaW5lbGlnaWJsZSBpZiBpdHMgZXhwb3J0cyBhcmUgaW5jb21wYXRpYmxlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIGV4cG9ydHMuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlLCBpZiB5b3UgYWRkL3JlbW92ZS9jaGFuZ2UgZXhwb3J0cywgd2UnbGwgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyByZS1leGVjdXRlIHRoZSBpbXBvcnRpbmcgbW9kdWxlcywgYW5kIGZvcmNlIHRob3NlIGNvbXBvbmVudHMgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtcmVuZGVyLiBTaW1pbGFybHksIGlmIHlvdSBjb252ZXJ0IGEgY2xhc3MgY29tcG9uZW50IHRvIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gZnVuY3Rpb24sIHdlIHdhbnQgdG8gaW52YWxpZGF0ZSB0aGUgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLiRSZWZyZXNoSGVscGVycyQuc2hvdWxkSW52YWxpZGF0ZVJlYWN0UmVmcmVzaEJvdW5kYXJ5KHByZXZTaWduYXR1cmUsIHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5nZXRSZWZyZXNoQm91bmRhcnlTaWduYXR1cmUoY3VycmVudEV4cG9ydHMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX193ZWJwYWNrX21vZHVsZV9fLmhvdC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLiRSZWZyZXNoSGVscGVycyQuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGp1c3QgZXhlY3V0ZWQgdGhlIGNvZGUgZm9yIHRoZSBtb2R1bGUsIGl0J3MgcG9zc2libGUgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXcgZXhwb3J0cyBtYWRlIGl0IGluZWxpZ2libGUgZm9yIGJlaW5nIGEgYm91bmRhcnkuXG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSBjYXJlIGFib3V0IHRoZSBjYXNlIHdoZW4gd2Ugd2VyZSBfcHJldmlvdXNseV8gYSBib3VuZGFyeSxcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFscmVhZHkgYWNjZXB0ZWQgdGhpcyB1cGRhdGUgKGFjY2lkZW50YWwgc2lkZSBlZmZlY3QpLlxuICAgICAgICAgICAgICAgIHZhciBpc05vTG9uZ2VyQUJvdW5kYXJ5ID0gcHJldlNpZ25hdHVyZSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb0xvbmdlckFCb3VuZGFyeSkge1xuICAgICAgICAgICAgICAgICAgICBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmludmFsaWRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/__barrel_optimize__?names=useCallback,useRef!=!./node_modules/next/dist/compiled/react/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/__barrel_optimize__?names=useMemo!=!./node_modules/next/dist/compiled/react/index.js":
/*!********************************************************************************************!*\
  !*** __barrel_optimize__?names=useMemo!=!./node_modules/next/dist/compiled/react/index.js ***!
  \********************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/react/index.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return C_Users_ck_LandingProspera_prospera_nextjs_node_modules_next_dist_compiled_react_index_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS9fX2JhcnJlbF9vcHRpbWl6ZV9fP25hbWVzPXVzZU1lbW8hPSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQWtCO0FBQ25EO0FBQ0EsNENBQTRDLE1BQWtCO0FBQzlEO0FBQ0E7QUFDQSxpRkFBaUYsU0FBcUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFrQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9pbmRleC5qcz85MTg1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gXCJDOlxcXFxVc2Vyc1xcXFxja1xcXFxMYW5kaW5nUHJvc3BlcmFcXFxccHJvc3BlcmEtbmV4dGpzXFxcXG5vZGVfbW9kdWxlc1xcXFxuZXh0XFxcXGRpc3RcXFxcY29tcGlsZWRcXFxccmVhY3RcXFxcaW5kZXguanNcIlxuXG47XG4gICAgLy8gV3JhcHBlZCBpbiBhbiBJSUZFIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ2xvYmFsIHNjb3BlXG4gICAgO1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIExlZ2FjeSBDU1MgaW1wbGVtZW50YXRpb25zIHdpbGwgYGV2YWxgIGJyb3dzZXIgY29kZSBpbiBhIE5vZGUuanMgY29udGV4dFxuICAgICAgICAvLyB0byBleHRyYWN0IENTUy4gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB3ZSBuZWVkIHRvIGNoZWNrIHdlJ3JlIGluIGFcbiAgICAgICAgLy8gYnJvd3NlciBjb250ZXh0IGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAvLyBBTVAgLyBOby1KUyBtb2RlIGRvZXMgbm90IGluamVjdCB0aGVzZSBoZWxwZXJzOlxuICAgICAgICAgICAgJyRSZWZyZXNoSGVscGVycyQnIGluIHNlbGYpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX193ZWJwYWNrX21vZHVsZV9fIGlzIGdsb2JhbFxuICAgICAgICAgICAgdmFyIGN1cnJlbnRFeHBvcnRzID0gX193ZWJwYWNrX21vZHVsZV9fLmV4cG9ydHM7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIF9fd2VicGFja19tb2R1bGVfXyBpcyBnbG9iYWxcbiAgICAgICAgICAgIHZhciBwcmV2U2lnbmF0dXJlID0gKF9iID0gKF9hID0gX193ZWJwYWNrX21vZHVsZV9fLmhvdC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJldlNpZ25hdHVyZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGhhcHBlbiBpbiBNYWluVGVtcGxhdGUgYmVjYXVzZSB0aGUgZXhwb3J0cyBtaXNtYXRjaCBiZXR3ZWVuXG4gICAgICAgICAgICAvLyB0ZW1wbGF0aW5nIGFuZCBleGVjdXRpb24uXG4gICAgICAgICAgICBzZWxmLiRSZWZyZXNoSGVscGVycyQucmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoKGN1cnJlbnRFeHBvcnRzLCBfX3dlYnBhY2tfbW9kdWxlX18uaWQpO1xuICAgICAgICAgICAgLy8gQSBtb2R1bGUgY2FuIGJlIGFjY2VwdGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGV4cG9ydHMsIGUuZy4gd2hlblxuICAgICAgICAgICAgLy8gaXQgaXMgYSBSZWZyZXNoIEJvdW5kYXJ5LlxuICAgICAgICAgICAgaWYgKHNlbGYuJFJlZnJlc2hIZWxwZXJzJC5pc1JlYWN0UmVmcmVzaEJvdW5kYXJ5KGN1cnJlbnRFeHBvcnRzKSkge1xuICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIHByZXZpb3VzIGV4cG9ydHMgc2lnbmF0dXJlIG9uIHVwZGF0ZSBzbyB3ZSBjYW4gY29tcGFyZSB0aGUgYm91bmRhcnlcbiAgICAgICAgICAgICAgICAvLyBzaWduYXR1cmVzLiBXZSBhdm9pZCBzYXZpbmcgZXhwb3J0cyB0aGVtc2VsdmVzIHNpbmNlIGl0IGNhdXNlcyBtZW1vcnkgbGVha3MgKGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9wdWxsLzUzNzk3KVxuICAgICAgICAgICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnByZXZTaWduYXR1cmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kUmVmcmVzaEhlbHBlcnMkLmdldFJlZnJlc2hCb3VuZGFyeVNpZ25hdHVyZShjdXJyZW50RXhwb3J0cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVW5jb25kaXRpb25hbGx5IGFjY2VwdCBhbiB1cGRhdGUgdG8gdGhpcyBtb2R1bGUsIHdlJ2xsIGNoZWNrIGlmIGl0J3NcbiAgICAgICAgICAgICAgICAvLyBzdGlsbCBhIFJlZnJlc2ggQm91bmRhcnkgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbXBvcnRNZXRhIGlzIHJlcGxhY2VkIGluIHRoZSBsb2FkZXJcbiAgICAgICAgICAgICAgICBpbXBvcnQubWV0YS53ZWJwYWNrSG90LmFjY2VwdCgpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZmllbGQgaXMgc2V0IHdoZW4gdGhlIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBtb2R1bGUgd2FzIGFcbiAgICAgICAgICAgICAgICAvLyBSZWZyZXNoIEJvdW5kYXJ5LCBsZXR0aW5nIHVzIGtub3cgd2UgbmVlZCB0byBjaGVjayBmb3IgaW52YWxpZGF0aW9uIG9yXG4gICAgICAgICAgICAgICAgLy8gZW5xdWV1ZSBhbiB1cGRhdGUuXG4gICAgICAgICAgICAgICAgaWYgKHByZXZTaWduYXR1cmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBib3VuZGFyeSBjYW4gYmVjb21lIGluZWxpZ2libGUgaWYgaXRzIGV4cG9ydHMgYXJlIGluY29tcGF0aWJsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBleHBvcnRzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZSwgaWYgeW91IGFkZC9yZW1vdmUvY2hhbmdlIGV4cG9ydHMsIHdlJ2xsIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gcmUtZXhlY3V0ZSB0aGUgaW1wb3J0aW5nIG1vZHVsZXMsIGFuZCBmb3JjZSB0aG9zZSBjb21wb25lbnRzIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLXJlbmRlci4gU2ltaWxhcmx5LCBpZiB5b3UgY29udmVydCBhIGNsYXNzIGNvbXBvbmVudCB0byBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uLCB3ZSB3YW50IHRvIGludmFsaWRhdGUgdGhlIGJvdW5kYXJ5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi4kUmVmcmVzaEhlbHBlcnMkLnNob3VsZEludmFsaWRhdGVSZWFjdFJlZnJlc2hCb3VuZGFyeShwcmV2U2lnbmF0dXJlLCBzZWxmLiRSZWZyZXNoSGVscGVycyQuZ2V0UmVmcmVzaEJvdW5kYXJ5U2lnbmF0dXJlKGN1cnJlbnRFeHBvcnRzKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9fd2VicGFja19tb2R1bGVfXy5ob3QuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi4kUmVmcmVzaEhlbHBlcnMkLnNjaGVkdWxlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBqdXN0IGV4ZWN1dGVkIHRoZSBjb2RlIGZvciB0aGUgbW9kdWxlLCBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV3IGV4cG9ydHMgbWFkZSBpdCBpbmVsaWdpYmxlIGZvciBiZWluZyBhIGJvdW5kYXJ5LlxuICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgY2FyZSBhYm91dCB0aGUgY2FzZSB3aGVuIHdlIHdlcmUgX3ByZXZpb3VzbHlfIGEgYm91bmRhcnksXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB3ZSBhbHJlYWR5IGFjY2VwdGVkIHRoaXMgdXBkYXRlIChhY2NpZGVudGFsIHNpZGUgZWZmZWN0KS5cbiAgICAgICAgICAgICAgICB2YXIgaXNOb0xvbmdlckFCb3VuZGFyeSA9IHByZXZTaWduYXR1cmUgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9Mb25nZXJBQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgX193ZWJwYWNrX21vZHVsZV9fLmhvdC5pbnZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/__barrel_optimize__?names=useMemo!=!./node_modules/next/dist/compiled/react/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx":
/*!**********************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx ***!
  \**********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NeuralParticleSystem.module.css */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css\");\n/* harmony import */ var _NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _hooks_useAnimationFrame__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/hooks/useAnimationFrame */ \"(app-pages-browser)/./src/hooks/useAnimationFrame.ts\");\n/* harmony import */ var _hooks_useNeuralParticles__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useNeuralParticles */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useNeuralParticles.ts\");\n/* harmony import */ var _hooks_useMatrixEffect__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks/useMatrixEffect */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useMatrixEffect.ts\");\n/* harmony import */ var _hooks_useDataTransfer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useDataTransfer */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useDataTransfer.ts\");\n/* harmony import */ var _hooks_useThemeColors__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @/hooks/useThemeColors */ \"(app-pages-browser)/./src/hooks/useThemeColors.ts\");\n// src/components/NeuralParticleSystem/NeuralParticleSystem.tsx\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\nconst NeuralParticleSystem = (param)=>{\n    let { density = 60, interactive = true, reactToClick = true, connectDistance = 150, colorScheme = \"green\", matrixEffect = true, dataTransferEffect = true, codeFragmentDensity = 30, flowDirection = \"down\", pulseNodes = true, enableGlow = true } = param;\n    _s();\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const isResizingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const isInitializedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const lastParticleTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    // Get theme colors\n    const themeColors = (0,_hooks_useThemeColors__WEBPACK_IMPORTED_MODULE_7__.useThemeColors)(colorScheme);\n    // Use custom hooks for different particle systems\n    const { canvasRef: mainCanvasRef, particles, updateParticles, addParticles, initParticles } = (0,_hooks_useNeuralParticles__WEBPACK_IMPORTED_MODULE_4__.useNeuralParticles)({\n        density,\n        connectDistance,\n        pulseNodes,\n        enableGlow,\n        themeColors\n    });\n    const { canvasRef: matrixCanvasRef, updateMatrix, initMatrix, addMatrixFragments } = (0,_hooks_useMatrixEffect__WEBPACK_IMPORTED_MODULE_5__.useMatrixEffect)({\n        enabled: matrixEffect,\n        density: codeFragmentDensity,\n        flowDirection,\n        themeColors\n    });\n    const { canvasRef: dataCanvasRef, updateDataTransfer, initDataTransfer } = (0,_hooks_useDataTransfer__WEBPACK_IMPORTED_MODULE_6__.useDataTransfer)({\n        enabled: dataTransferEffect,\n        enableGlow,\n        themeColors\n    });\n    // Optimize canvas setup\n    const setupCanvas = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((canvas, dimensions)=>{\n        if (!canvas) return null;\n        const dpr = window.devicePixelRatio || 1;\n        canvas.width = dimensions.width * dpr;\n        canvas.height = dimensions.height * dpr;\n        const ctx = canvas.getContext(\"2d\", {\n            alpha: true,\n            desynchronized: true,\n            willReadFrequently: false\n        });\n        if (ctx) {\n            ctx.scale(dpr, dpr);\n        }\n        return ctx;\n    }, []);\n    // Handle resize with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleResize = ()=>{\n            isResizingRef.current = true;\n            if (containerRef.current) {\n                const { offsetWidth, offsetHeight } = containerRef.current;\n                // Setup all canvases\n                setupCanvas(mainCanvasRef.current, {\n                    width: offsetWidth,\n                    height: offsetHeight\n                });\n                if (matrixEffect) setupCanvas(matrixCanvasRef.current, {\n                    width: offsetWidth,\n                    height: offsetHeight\n                });\n                if (dataTransferEffect) setupCanvas(dataCanvasRef.current, {\n                    width: offsetWidth,\n                    height: offsetHeight\n                });\n                // Reinitialize systems if needed\n                if (isInitializedRef.current) {\n                    initParticles(offsetWidth, offsetHeight);\n                    if (matrixEffect) initMatrix(offsetWidth, offsetHeight);\n                    if (dataTransferEffect) initDataTransfer();\n                }\n            }\n            isResizingRef.current = false;\n        };\n        handleResize();\n        let resizeTimer;\n        const throttledResize = ()=>{\n            clearTimeout(resizeTimer);\n            resizeTimer = setTimeout(handleResize, 100);\n        };\n        window.addEventListener(\"resize\", throttledResize, {\n            passive: true\n        });\n        return ()=>{\n            window.removeEventListener(\"resize\", throttledResize);\n            clearTimeout(resizeTimer);\n        };\n    }, [\n        setupCanvas,\n        matrixEffect,\n        dataTransferEffect,\n        initParticles,\n        initMatrix,\n        initDataTransfer\n    ]);\n    // Initialize on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitializedRef.current && containerRef.current) {\n            const { offsetWidth, offsetHeight } = containerRef.current;\n            initParticles(offsetWidth, offsetHeight);\n            if (matrixEffect) initMatrix(offsetWidth, offsetHeight);\n            if (dataTransferEffect) initDataTransfer();\n            isInitializedRef.current = true;\n        }\n    }, [\n        initParticles,\n        initMatrix,\n        initDataTransfer,\n        matrixEffect,\n        dataTransferEffect\n    ]);\n    // Optimize mouse interaction\n    const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (!interactive || isResizingRef.current || !containerRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        // Throttle particle creation\n        const now = Date.now();\n        if (now - lastParticleTimeRef.current > 50) {\n            addParticles(x, y, 1);\n            lastParticleTimeRef.current = now;\n        }\n    }, [\n        interactive,\n        addParticles\n    ]);\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((e)=>{\n        if (!reactToClick || !containerRef.current) return;\n        const rect = containerRef.current.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        addParticles(x, y, 10);\n        if (matrixEffect) addMatrixFragments(x, y, 10);\n    }, [\n        reactToClick,\n        addParticles,\n        matrixEffect,\n        addMatrixFragments\n    ]);\n    // Event listeners\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const container = containerRef.current;\n        if (!container) return;\n        container.addEventListener(\"mousemove\", handleMouseMove, {\n            passive: true\n        });\n        container.addEventListener(\"click\", handleClick);\n        return ()=>{\n            container.removeEventListener(\"mousemove\", handleMouseMove);\n            container.removeEventListener(\"click\", handleClick);\n        };\n    }, [\n        handleMouseMove,\n        handleClick\n    ]);\n    // Main animation loop using optimized RAF hook\n    (0,_hooks_useAnimationFrame__WEBPACK_IMPORTED_MODULE_3__.useAnimationFrame)((deltaTime)=>{\n        if (isResizingRef.current) return;\n        updateParticles(deltaTime);\n        if (matrixEffect) updateMatrix(deltaTime);\n        if (dataTransferEffect) updateDataTransfer(deltaTime);\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"\".concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().container), \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default())[colorScheme], \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().active)),\n        \"aria-hidden\": \"true\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: mainCanvasRef,\n                className: (_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().canvas)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n                lineNumber: 214,\n                columnNumber: 7\n            }, undefined),\n            matrixEffect && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: matrixCanvasRef,\n                className: \"\".concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().canvas), \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().matrixCanvas))\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n                lineNumber: 216,\n                columnNumber: 9\n            }, undefined),\n            dataTransferEffect && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: dataCanvasRef,\n                className: \"\".concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().canvas), \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().dataCanvas))\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n                lineNumber: 219,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n        lineNumber: 209,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NeuralParticleSystem, \"SW3M1+7MFXAhRVeEpddhOLhNwLc=\", false, function() {\n    return [\n        _hooks_useThemeColors__WEBPACK_IMPORTED_MODULE_7__.useThemeColors,\n        _hooks_useNeuralParticles__WEBPACK_IMPORTED_MODULE_4__.useNeuralParticles,\n        _hooks_useMatrixEffect__WEBPACK_IMPORTED_MODULE_5__.useMatrixEffect,\n        _hooks_useDataTransfer__WEBPACK_IMPORTED_MODULE_6__.useDataTransfer,\n        _hooks_useAnimationFrame__WEBPACK_IMPORTED_MODULE_3__.useAnimationFrame\n    ];\n});\n_c = NeuralParticleSystem;\n/* harmony default export */ __webpack_exports__[\"default\"] = (/*#__PURE__*/_c1 = react__WEBPACK_IMPORTED_MODULE_1___default().memo(NeuralParticleSystem));\nvar _c, _c1;\n$RefreshReg$(_c, \"NeuralParticleSystem\");\n$RefreshReg$(_c1, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL05ldXJhbFBhcnRpY2xlU3lzdGVtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLCtEQUErRDs7O0FBR1E7QUFDaEI7QUFDTztBQUNFO0FBQ047QUFDQTtBQUNGO0FBZ0J4RCxNQUFNVSx1QkFBNEQ7UUFBQyxFQUNqRUMsVUFBVSxFQUFFLEVBQ1pDLGNBQWMsSUFBSSxFQUNsQkMsZUFBZSxJQUFJLEVBQ25CQyxrQkFBa0IsR0FBRyxFQUNyQkMsY0FBYyxPQUFPLEVBQ3JCQyxlQUFlLElBQUksRUFDbkJDLHFCQUFxQixJQUFJLEVBQ3pCQyxzQkFBc0IsRUFBRSxFQUN4QkMsZ0JBQWdCLE1BQU0sRUFDdEJDLGFBQWEsSUFBSSxFQUNqQkMsYUFBYSxJQUFJLEVBQ2xCOztJQUNDLE1BQU1DLGVBQWVyQiw2Q0FBTUEsQ0FBaUI7SUFDNUMsTUFBTXNCLGdCQUFnQnRCLDZDQUFNQSxDQUFVO0lBQ3RDLE1BQU11QixtQkFBbUJ2Qiw2Q0FBTUEsQ0FBVTtJQUN6QyxNQUFNd0Isc0JBQXNCeEIsNkNBQU1BLENBQVM7SUFFM0MsbUJBQW1CO0lBQ25CLE1BQU15QixjQUFjakIscUVBQWNBLENBQUNNO0lBRW5DLGtEQUFrRDtJQUNsRCxNQUFNLEVBQ0pZLFdBQVdDLGFBQWEsRUFDeEJDLFNBQVMsRUFDVEMsZUFBZSxFQUNmQyxZQUFZLEVBQ1pDLGFBQWEsRUFDZCxHQUFHMUIsNkVBQWtCQSxDQUFDO1FBQ3JCSztRQUNBRztRQUNBTTtRQUNBQztRQUNBSztJQUNGO0lBRUEsTUFBTSxFQUNKQyxXQUFXTSxlQUFlLEVBQzFCQyxZQUFZLEVBQ1pDLFVBQVUsRUFDVkMsa0JBQWtCLEVBQ25CLEdBQUc3Qix1RUFBZUEsQ0FBQztRQUNsQjhCLFNBQVNyQjtRQUNUTCxTQUFTTztRQUNUQztRQUNBTztJQUNGO0lBRUEsTUFBTSxFQUNKQyxXQUFXVyxhQUFhLEVBQ3hCQyxrQkFB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LGFBQWE4QztRQUMvQixJQUFJL0Qsb0JBQW9Cc0IsbUJBQW1CeUM7SUFDN0M7SUFFQSxxQkFDRSw4REFBQ0M7UUFDQ0MsS0FBSzVEO1FBQ0w2RCxXQUFXLEdBQXVCL0UsT0FBcEJBLG1GQUFnQixFQUFDLEtBQTBCQSxPQUF2QkEseUVBQU0sQ0FBQ1csWUFBWSxFQUFDLEtBQWlCLE9BQWRYLGdGQUFhO1FBQ3RFaUYsZUFBWTs7MEJBRVosOERBQUMzQztnQkFBT3dDLEtBQUt0RDtnQkFBZXVELFdBQVcvRSxnRkFBYTs7Ozs7O1lBQ25EWSw4QkFDQyw4REFBQzBCO2dCQUFPd0MsS0FBS2pEO2dCQUFpQmtELFdBQVcsR0FBb0IvRSxPQUFqQkEsZ0ZBQWEsRUFBQyxLQUF1QixPQUFwQkEsc0ZBQW1COzs7Ozs7WUFFakZhLG9DQUNDLDhEQUFDeUI7Z0JBQU93QyxLQUFLNUM7Z0JBQWU2QyxXQUFXLEdBQW9CL0UsT0FBakJBLGdGQUFhLEVBQUMsS0FBcUIsT0FBbEJBLG9GQUFpQjs7Ozs7Ozs7Ozs7O0FBSXBGO0dBck1NTTs7UUFtQmdCRCxpRUFBY0E7UUFTOUJILHlFQUFrQkE7UUFhbEJDLG1FQUFlQTtRQVdmQyxtRUFBZUE7UUEwSG5CSCx1RUFBaUJBOzs7S0E5S2JLO0FBdU1OLGtGQUFlVixpREFBVSxDQUFDVSxxQkFBcUJBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTmV1cmFsUGFydGljbGVTeXN0ZW0vTmV1cmFsUGFydGljbGVTeXN0ZW0udHN4PzViZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NvbXBvbmVudHMvTmV1cmFsUGFydGljbGVTeXN0ZW0vTmV1cmFsUGFydGljbGVTeXN0ZW0udHN4XHJcbid1c2UgY2xpZW50JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9OZXVyYWxQYXJ0aWNsZVN5c3RlbS5tb2R1bGUuY3NzJztcclxuaW1wb3J0IHsgdXNlQW5pbWF0aW9uRnJhbWUgfSBmcm9tICdAL2hvb2tzL3VzZUFuaW1hdGlvbkZyYW1lJztcclxuaW1wb3J0IHsgdXNlTmV1cmFsUGFydGljbGVzIH0gZnJvbSAnLi9ob29rcy91c2VOZXVyYWxQYXJ0aWNsZXMnO1xyXG5pbXBvcnQgeyB1c2VNYXRyaXhFZmZlY3QgfSBmcm9tICcuL2hvb2tzL3VzZU1hdHJpeEVmZmVjdCc7XHJcbmltcG9ydCB7IHVzZURhdGFUcmFuc2ZlciB9IGZyb20gJy4vaG9va3MvdXNlRGF0YVRyYW5zZmVyJztcclxuaW1wb3J0IHsgdXNlVGhlbWVDb2xvcnMgfSBmcm9tICdAL2hvb2tzL3VzZVRoZW1lQ29sb3JzJztcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTmV1cmFsUGFydGljbGVTeXN0ZW1Qcm9wcyB7XHJcbiAgZGVuc2l0eT86IG51bWJlcjtcclxuICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XHJcbiAgcmVhY3RUb0NsaWNrPzogYm9vbGVhbjtcclxuICBjb25uZWN0RGlzdGFuY2U/OiBudW1iZXI7XHJcbiAgY29sb3JTY2hlbWU/OiAnZ3JlZW4nIHwgJ2JsdWUnIHwgJ3B1cnBsZScgfCAnbXVsdGknIHwgJ3JlZCcgfCAnY3lhbic7XHJcbiAgbWF0cml4RWZmZWN0PzogYm9vbGVhbjtcclxuICBkYXRhVHJhbnNmZXJFZmZlY3Q/OiBib29sZWFuO1xyXG4gIGNvZGVGcmFnbWVudERlbnNpdHk/OiBudW1iZXI7XHJcbiAgZmxvd0RpcmVjdGlvbj86ICdkb3duJyB8ICd1cCcgfCAncmFuZG9tJztcclxuICBwdWxzZU5vZGVzPzogYm9vbGVhbjtcclxuICBlbmFibGVHbG93PzogYm9vbGVhbjtcclxufVxyXG5cclxuY29uc3QgTmV1cmFsUGFydGljbGVTeXN0ZW06IFJlYWN0LkZDPE5ldXJhbFBhcnRpY2xlU3lzdGVtUHJvcHM+ID0gKHtcclxuICBkZW5zaXR5ID0gNjAsXHJcbiAgaW50ZXJhY3RpdmUgPSB0cnVlLFxyXG4gIHJlYWN0VG9DbGljayA9IHRydWUsXHJcbiAgY29ubmVjdERpc3RhbmNlID0gMTUwLFxyXG4gIGNvbG9yU2NoZW1lID0gJ2dyZWVuJyxcclxuICBtYXRyaXhFZmZlY3QgPSB0cnVlLFxyXG4gIGRhdGFUcmFuc2ZlckVmZmVjdCA9IHRydWUsXHJcbiAgY29kZUZyYWdtZW50RGVuc2l0eSA9IDMwLFxyXG4gIGZsb3dEaXJlY3Rpb24gPSAnZG93bicsXHJcbiAgcHVsc2VOb2RlcyA9IHRydWUsXHJcbiAgZW5hYmxlR2xvdyA9IHRydWVcclxufSkgPT4ge1xyXG4gIGNvbnN0IGNvbnRhaW5lclJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgaXNSZXNpemluZ1JlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgaXNJbml0aWFsaXplZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcbiAgY29uc3QgbGFzdFBhcnRpY2xlVGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIFxyXG4gIC8vIEdldCB0aGVtZSBjb2xvcnNcclxuICBjb25zdCB0aGVtZUNvbG9ycyA9IHVzZVRoZW1lQ29sb3JzKGNvbG9yU2NoZW1lKTtcclxuICBcclxuICAvLyBVc2UgY3VzdG9tIGhvb2tzIGZvciBkaWZmZXJlbnQgcGFydGljbGUgc3lzdGVtc1xyXG4gIGNvbnN0IHtcclxuICAgIGNhbnZhc1JlZjogbWFpbkNhbnZhc1JlZixcclxuICAgIHBhcnRpY2xlcyxcclxuICAgIHVwZGF0ZVBhcnRpY2xlcyxcclxuICAgIGFkZFBhcnRpY2xlcyxcclxuICAgIGluaXRQYXJ0aWNsZXNcclxuICB9ID0gdXNlTmV1cmFsUGFydGljbGVzKHtcclxuICAgIGRlbnNpdHksXHJcbiAgICBjb25uZWN0RGlzdGFuY2UsXHJcbiAgICBwdWxzZU5vZGVzLFxyXG4gICAgZW5hYmxlR2xvdyxcclxuICAgIHRoZW1lQ29sb3JzXHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc3Qge1xyXG4gICAgY2FudmFzUmVmOiBtYXRyaXhDYW52YXNSZWYsXHJcbiAgICB1cGRhdGVNYXRyaXgsXHJcbiAgICBpbml0TWF0cml4LFxyXG4gICAgYWRkTWF0cml4RnJhZ21lbnRzXHJcbiAgfSA9IHVzZU1hdHJpeEVmZmVjdCh7XHJcbiAgICBlbmFibGVkOiBtYXRyaXhFZmZlY3QsXHJcbiAgICBkZW5zaXR5OiBjb2RlRnJhZ21lbnREZW5zaXR5LFxyXG4gICAgZmxvd0RpcmVjdGlvbixcclxuICAgIHRoZW1lQ29sb3JzXHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc3Qge1xyXG4gICAgY2FudmFzUmVmOiBkYXRhQ2FudmFzUmVmLFxyXG4gICAgdXBkYXRlRGF0YVRyYW5zZmVyLFxyXG4gICAgaW5pdERhdGFUcmFuc2ZlclxyXG4gIH0gPSB1c2VEYXRhVHJhbnNmZXIoe1xyXG4gICAgZW5hYmxlZDogZGF0YVRyYW5zZmVyRWZmZWN0LFxyXG4gICAgZW5hYmxlR2xvdyxcclxuICAgIHRoZW1lQ29sb3JzXHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gT3B0aW1pemUgY2FudmFzIHNldHVwXHJcbiAgY29uc3Qgc2V0dXBDYW52YXMgPSB1c2VDYWxsYmFjaygoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwsIGRpbWVuc2lvbnM6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfSkgPT4ge1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCAqIGRwcjtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCAqIGRwcjtcclxuICAgIFxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywge1xyXG4gICAgICBhbHBoYTogdHJ1ZSxcclxuICAgICAgZGVzeW5jaHJvbml6ZWQ6IHRydWUsXHJcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpZiAoY3R4KSB7XHJcbiAgICAgIGN0eC5zY2FsZShkcHIsIGRwcik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBjdHg7XHJcbiAgfSwgW10pO1xyXG4gIFxyXG4gIC8vIEhhbmRsZSByZXNpemUgd2l0aCBkZWJvdW5jZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgIGlzUmVzaXppbmdSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgIFxyXG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNldHVwIGFsbCBjYW52YXNlc1xyXG4gICAgICAgIHNldHVwQ2FudmFzKG1haW5DYW52YXNSZWYuY3VycmVudCwgeyB3aWR0aDogb2Zmc2V0V2lkdGgsIGhlaWdodDogb2Zmc2V0SGVpZ2h0IH0pO1xyXG4gICAgICAgIGlmIChtYXRyaXhFZmZlY3QpIHNldHVwQ2FudmFzKG1hdHJpeENhbnZhc1JlZi5jdXJyZW50LCB7IHdpZHRoOiBvZmZzZXRXaWR0aCwgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfSk7XHJcbiAgICAgICAgaWYgKGRhdGFUcmFuc2ZlckVmZmVjdCkgc2V0dXBDYW52YXMoZGF0YUNhbnZhc1JlZi5jdXJyZW50LCB7IHdpZHRoOiBvZmZzZXRXaWR0aCwgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVpbml0aWFsaXplIHN5c3RlbXMgaWYgbmVlZGVkXHJcbiAgICAgICAgaWYgKGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgaW5pdFBhcnRpY2xlcyhvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICAgIGlmIChtYXRyaXhFZmZlY3QpIGluaXRNYXRyaXgob2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCk7XHJcbiAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyRWZmZWN0KSBpbml0RGF0YVRyYW5zZmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGhhbmRsZVJlc2l6ZSgpO1xyXG4gICAgXHJcbiAgICBsZXQgcmVzaXplVGltZXI6IE5vZGVKUy5UaW1lb3V0O1xyXG4gICAgY29uc3QgdGhyb3R0bGVkUmVzaXplID0gKCkgPT4ge1xyXG4gICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXIpO1xyXG4gICAgICByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlUmVzaXplLCAxMDApO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRocm90dGxlZFJlc2l6ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhyb3R0bGVkUmVzaXplKTtcclxuICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVyKTtcclxuICAgIH07XHJcbiAgfSwgW3NldHVwQ2FudmFzLCBtYXRyaXhFZmZlY3QsIGRhdGFUcmFuc2ZlckVmZmVjdCwgaW5pdFBhcnRpY2xlcywgaW5pdE1hdHJpeCwgaW5pdERhdGFUcmFuc2Zlcl0pO1xyXG4gIFxyXG4gIC8vIEluaXRpYWxpemUgb24gbW91bnRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0luaXRpYWxpemVkUmVmLmN1cnJlbnQgJiYgY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0IH0gPSBjb250YWluZXJSZWYuY3VycmVudDtcclxuICAgICAgXHJcbiAgICAgIGluaXRQYXJ0aWNsZXMob2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCk7XHJcbiAgICAgIGlmIChtYXRyaXhFZmZlY3QpIGluaXRNYXRyaXgob2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCk7XHJcbiAgICAgIGlmIChkYXRhVHJhbnNmZXJFZmZlY3QpIGluaXREYXRhVHJhbnNmZXIoKTtcclxuICAgICAgXHJcbiAgICAgIGlzSW5pdGlhbGl6ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICB9XHJcbiAgfSwgW2luaXRQYXJ0aWNsZXMsIGluaXRNYXRyaXgsIGluaXREYXRhVHJhbnNmZXIsIG1hdHJpeEVmZmVjdCwgZGF0YVRyYW5zZmVyRWZmZWN0XSk7XHJcbiAgXHJcbiAgLy8gT3B0aW1pemUgbW91c2UgaW50ZXJhY3Rpb25cclxuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSB1c2VDYWxsYmFjaygoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgaWYgKCFpbnRlcmFjdGl2ZSB8fCBpc1Jlc2l6aW5nUmVmLmN1cnJlbnQgfHwgIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XHJcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XHJcbiAgICBcclxuICAgIC8vIFRocm90dGxlIHBhcnRpY2xlIGNyZWF0aW9uXHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgaWYgKG5vdyAtIGxhc3RQYXJ0aWNsZVRpbWVSZWYuY3VycmVudCA+IDUwKSB7XHJcbiAgICAgIGFkZFBhcnRpY2xlcyh4LCB5LCAxKTtcclxuICAgICAgbGFzdFBhcnRpY2xlVGltZVJlZi5jdXJyZW50ID0gbm93O1xyXG4gICAgfVxyXG4gIH0sIFtpbnRlcmFjdGl2ZSwgYWRkUGFydGljbGVzXSk7XHJcbiAgXHJcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjaygoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgaWYgKCFyZWFjdFRvQ2xpY2sgfHwgIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnQ7XHJcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3A7XHJcbiAgICBcclxuICAgIGFkZFBhcnRpY2xlcyh4LCB5LCAxMCk7XHJcbiAgICBpZiAobWF0cml4RWZmZWN0KSBhZGRNYXRyaXhGcmFnbWVudHMoeCwgeSwgMTApO1xyXG4gIH0sIFtyZWFjdFRvQ2xpY2ssIGFkZFBhcnRpY2xlcywgbWF0cml4RWZmZWN0LCBhZGRNYXRyaXhGcmFnbWVudHNdKTtcclxuICBcclxuICAvLyBFdmVudCBsaXN0ZW5lcnNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgY29udGFpbmVyID0gY29udGFpbmVyUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xyXG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XHJcbiAgICB9O1xyXG4gIH0sIFtoYW5kbGVNb3VzZU1vdmUsIGhhbmRsZUNsaWNrXSk7XHJcbiAgXHJcbiAgLy8gTWFpbiBhbmltYXRpb24gbG9vcCB1c2luZyBvcHRpbWl6ZWQgUkFGIGhvb2tcclxuICB1c2VBbmltYXRpb25GcmFtZSgoZGVsdGFUaW1lKSA9PiB7XHJcbiAgICBpZiAoaXNSZXNpemluZ1JlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICBcclxuICAgIHVwZGF0ZVBhcnRpY2xlcyhkZWx0YVRpbWUpO1xyXG4gICAgaWYgKG1hdHJpeEVmZmVjdCkgdXBkYXRlTWF0cml4KGRlbHRhVGltZSk7XHJcbiAgICBpZiAoZGF0YVRyYW5zZmVyRWZmZWN0KSB1cGRhdGVEYXRhVHJhbnNmZXIoZGVsdGFUaW1lKTtcclxuICB9KTtcclxuICBcclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBcclxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLmNvbnRhaW5lcn0gJHtzdHlsZXNbY29sb3JTY2hlbWVdfSAke3N0eWxlcy5hY3RpdmV9YH1cclxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgID5cclxuICAgICAgPGNhbnZhcyByZWY9e21haW5DYW52YXNSZWZ9IGNsYXNzTmFtZT17c3R5bGVzLmNhbnZhc30gLz5cclxuICAgICAge21hdHJpeEVmZmVjdCAmJiAoXHJcbiAgICAgICAgPGNhbnZhcyByZWY9e21hdHJpeENhbnZhc1JlZn0gY2xhc3NOYW1lPXtgJHtzdHlsZXMuY2FudmFzfSAke3N0eWxlcy5tYXRyaXhDYW52YXN9YH0gLz5cclxuICAgICAgKX1cclxuICAgICAge2RhdGFUcmFuc2ZlckVmZmVjdCAmJiAoXHJcbiAgICAgICAgPGNhbnZhcyByZWY9e2RhdGFDYW52YXNSZWZ9IGNsYXNzTmFtZT17YCR7c3R5bGVzLmNhbnZhc30gJHtzdHlsZXMuZGF0YUNhbnZhc31gfSAvPlxyXG4gICAgICApfVxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJlYWN0Lm1lbW8oTmV1cmFsUGFydGljbGVTeXN0ZW0pOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwic3R5bGVzIiwidXNlQW5pbWF0aW9uRnJhbWUiLCJ1c2VOZXVyYWxQYXJ0aWNsZXMiLCJ1c2VNYXRyaXhFZmZlY3QiLCJ1c2VEYXRhVHJhbnNmZXIiLCJ1c2VUaGVtZUNvbG9ycyIsIk5ldXJhbFBhcnRpY2xlU3lzdGVtIiwiZGVuc2l0eSIsImludGVyYWN0aXZlIiwicmVhY3RUb0NsaWNrIiwiY29ubmVjdERpc3RhbmNlIiwiY29sb3JTY2hlbWUiLCJtYXRyaXhFZmZlY3QiLCJkYXRhVHJhbnNmZXJFZmZlY3QiLCJjb2RlRnJhZ21lbnREZW5zaXR5IiwiZmxvd0RpcmVjdGlvbiIsInB1bHNlTm9kZXMiLCJlbmFibGVHbG93IiwiY29udGFpbmVyUmVmIiwiaXNSZXNpemluZ1JlZiIsImlzSW5pdGlhbGl6ZWRSZWYiLCJsYXN0UGFydGljbGVUaW1lUmVmIiwidGhlbWVDb2xvcnMiLCJjYW52YXNSZWYiLCJtYWluQ2FudmFzUmVmIiwicGFydGljbGVzIiwidXBkYXRlUGFydGljbGVzIiwiYWRkUGFydGljbGVzIiwiaW5pdFBhcnRpY2xlcyIsIm1hdHJpeENhbnZhc1JlZiIsInVwZGF0ZU1hdHJpeCIsImluaXRNYXRyaXgiLCJhZGRNYXRyaXhGcmFnbWVudHMiLCJlbmFibGVkIiwiZGF0YUNhbnZhc1JlZiIsInVwZGF0ZURhdGFUcmFuc2ZlciIsImluaXREYXRhVHJhbnNmZXIiLCJzZXR1cENhbnZhcyIsImNhbnZhcyIsImRpbWVuc2lvbnMiLCJkcHIiLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwid2lkdGgiLCJoZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiYWxwaGEiLCJkZXN5bmNocm9uaXplZCIsIndpbGxSZWFkRnJlcXVlbnRseSIsInNjYWxlIiwiaGFuZGxlUmVzaXplIiwiY3VycmVudCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwicmVzaXplVGltZXIiLCJ0aHJvdHRsZWRSZXNpemUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlTW91c2VNb3ZlIiwiZSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ4IiwiY2xpZW50WCIsImxlZnQiLCJ5IiwiY2xpZW50WSIsInRvcCIsIm5vdyIsIkRhdGUiLCJoYW5kbGVDbGljayIsImNvbnRhaW5lciIsImRlbHRhVGltZSIsImRpdiIsInJlZiIsImNsYXNzTmFtZSIsImFjdGl2ZSIsImFyaWEtaGlkZGVuIiwibWF0cml4Q2FudmFzIiwiZGF0YUNhbnZhcyIsIm1lbW8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useDataTransfer.ts":
/*!**********************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/hooks/useDataTransfer.ts ***!
  \**********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useDataTransfer: function() { return /* binding */ useDataTransfer; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=useCallback,useRef!=!react */ \"(app-pages-browser)/__barrel_optimize__?names=useCallback,useRef!=!./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ useDataTransfer auto */ \nfunction useDataTransfer(param) {\n    let { enabled, enableGlow, themeColors } = param;\n    const canvasRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const packetsRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const initDataTransfer = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        packetsRef.current = [];\n    }, []);\n    const createDataPacket = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((sourceIndex, targetIndex, particles)=>{\n        const source = particles[sourceIndex];\n        const target = particles[targetIndex];\n        if (!source || !target) return null;\n        return {\n            sourceIndex,\n            targetIndex,\n            x: source.x,\n            y: source.y,\n            progress: 0,\n            speed: Math.random() * 0.02 + 0.01,\n            color: themeColors.data || \"#00ff00\",\n            size: Math.random() * 1.5 + 1\n        };\n    }, [\n        themeColors\n    ]);\n    const updateDataTransfer = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((deltaTime)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\", {\n            alpha: true\n        });\n        if (!ctx) return;\n        const { width, height } = canvas;\n        ctx.clearRect(0, 0, width, height);\n        const packets = packetsRef.current;\n        const updatedPackets = [];\n        for(let i = 0; i < packets.length; i++){\n            const packet = packets[i];\n            packet.progress += packet.speed * deltaTime * 60;\n            if (packet.progress >= 1) {\n                continue;\n            }\n            // Simplified bezier curve calculation for example\n            const t = packet.progress;\n            const x = packet.x + t * 100; // Simplified movement\n            const y = packet.y + t * 100; // Simplified movement\n            // Draw packet with glow\n            if (enableGlow) {\n                const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, packet.size * 5);\n                glowGradient.addColorStop(0, packet.color.includes(\"rgb\") ? packet.color.replace(\")\", \", 0.5)\").replace(\"rgb\", \"rgba\") : \"\".concat(packet.color, \"80\"));\n                glowGradient.addColorStop(1, packet.color.includes(\"rgb\") ? packet.color.replace(\")\", \", 0)\").replace(\"rgb\", \"rgba\") : \"\".concat(packet.color, \"00\"));\n                ctx.beginPath();\n                ctx.fillStyle = glowGradient;\n                ctx.arc(x, y, packet.size * 5, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            ctx.beginPath();\n            ctx.fillStyle = packet.color;\n            ctx.arc(x, y, packet.size, 0, Math.PI * 2);\n            ctx.fill();\n            updatedPackets.push(packet);\n        }\n        packetsRef.current = updatedPackets;\n    }, [\n        enableGlow\n    ]);\n    return {\n        canvasRef,\n        updateDataTransfer,\n        initDataTransfer,\n        createDataPacket,\n        packets: packetsRef.current\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2hvb2tzL3VzZURhdGFUcmFuc2Zlci50cyIsIm1hcHBpbmdzIjoiOzs7OztxRUFFNEM7QUFtQnJDLFNBQVNFLGdCQUFnQixLQUlUO1FBSlMsRUFDOUJDLE9BQU8sRUFDUEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1UsR0FKUztJQUs5QixNQUFNQyxZQUFZTix1RkFBTUEsQ0FBb0I7SUFDNUMsTUFBTU8sYUFBYVAsdUZBQU1BLENBQWUsRUFBRTtJQUUxQyxNQUFNUSxtQkFBbUJQLDRGQUFXQSxDQUFDO1FBQ25DTSxXQUFXRSxPQUFPLEdBQUcsRUFBRTtJQUN6QixHQUFHLEVBQUU7SUFFTCxNQUFNQyxtQkFBbUJULDRGQUFXQSxDQUFDLENBQ25DVSxhQUNBQyxhQUNBQztRQUVBLE1BQU1DLFNBQVNELFNBQVMsQ0FBQ0YsWUFBWTtRQUNyQyxNQUFNSSxTQUFTRixTQUFTLENBQUNELFlBQVk7UUFFckMsSUFBSSxDQUFDRSxVQUFVLENBQUNDLFFBQVEsT0FBTztRQUUvQixPQUFPO1lBQ0xKO1lBQ0FDO1lBQ0FJLEdBQUdGLE9BQU9FLENBQUM7WUFDWEMsR0FBR0gsT0FBT0csQ0FBQztZQUNYQyxVQUFVO1lBQ1ZDLE9BQU9DLEtBQUtDLE1BQU0sS0FBSyxPQUFPO1lBQzlCQyxPQUFPakIsWUFBWWtCLElBQUksSUFBSTtZQUMzQkMsTUFBTUosS0FBS0MsTUFBTSxLQUFLLE1BQU07UUFDOUI7SUFDRixHQUFHO1FBQUNoQjtLQUFZO0lBRWhCLE1BQU1vQixxQkFBcUJ4Qiw0RkFBV0EsQ0FBQyxDQUFDeUI7UUFDdEMsTUFBTUMsU0FBU3JCLFVBQVVHLE9BQU87UUFDaEMsSUFBSSxDQUFDa0IsUUFBUTtRQUViLE1BQU1DLE1BQU1ELE9BQU9FLFVBQVUsQ0FBQyxNQUFNO1lBQUVDLE9BQU87UUFBSztRQUNsRCxJQUFJLENBQUNGLEtBQUs7UUFFVixNQUFNLEVBQUVHLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdMO1FBRTFCQyxJQUFJSyxTQUFTLENBQUMsR0FBRyxHQUFHRixPQUFPQztRQUUzQixNQUFNRSxVQUFVM0IsV0FBV0UsT0FBTztRQUNsQyxNQUFNMEIsaUJBQStCLEVBQUU7UUFFdkMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFHLE1BQU0sRUFBRUQsSUFBSztZQUN2QyxNQUFNRSxTQUFTSixPQUFPLENBQUNFLEVBQUU7WUFFekJFLE9BQU9wQixRQUFRLElBQUlvQixPQUFPbkIsS0FBSyxHQUFHTyxZQUFZO1lBRTlDLElBQUlZLE9BQU9wQixRQUFRLElBQUksR0FBRztnQkFDeEI7WUFDRjtZQUVBLGtEQUFrRDtZQUNsRCxNQUFNcUIsSUFBSUQsT0FBT3BCLFFBQVE7WUFDekIsTUFBTUYsSUFBSXNCLE9BQU90QixDQUFDLEdBQUd1QixJQUFJLEtBQUssc0JBQXNCO1lBQ3BELE1BQU10QixJQUFJcUIsT0FBT3JCLENBQUMsR0FBR3NCLElBQUksS0FBSyxzQkFBc0I7WUFFcEQsd0JBQXdCO1lBQ3hCLElBQUluQyxZQUFZO2dCQUNkLE1BQU1vQyxlQUFlWixJQUFJYSxvQkFBb0IsQ0FDM0N6QixHQUFHQyxHQUFHLEdBQ05ELEdBQUdDLEdBQUdxQixPQUFPZCxJQUFJLEdBQUc7Z0JBR3RCZ0IsYUFBYUUsWUFBWSxDQUFDLEdBQUdKLE9BQU9oQixLQUFLLENBQUNxQixRQUFRLENBQUMsU0FDL0NMLE9BQU9oQixLQUFLLENBQUNzQixPQUFPLENBQUMsS0FBSyxVQUFVQSxPQUFPLENBQUMsT0FBTyxVQUNuRCxHQUFnQixPQUFiTixPQUFPaEIsS0FBSyxFQUFDO2dCQUNwQmtCLGFBQWFFLFlBQVksQ0FBQyxHQUFHSixPQUFPaEIsS0FBSyxDQUFDcUIsUUFBUSxDQUFDLFNBQy9DTCxPQUFPaEIsS0FBSyxDQUFDc0IsT0FBTyxDQUFDLEtBQUssUUFBUUEsT0FBTyxDQUFDLE9BQU8sVUFDakQsR0FBZ0IsT0FBYk4sT0FBT2hCLEtBQUssRUFBQztnQkFFcEJNLElBQUlpQixTQUFTO2dCQUNiakIsSUFBSWtCLFNBQVMsR0FBR047Z0JBQ2hCWixJQUFJbUIsR0FBRyxDQUFDL0IsR0FBR0MsR0FBR3FCLE9BQU9kLElBQUksR0FBRyxHQUFHLEdBQUdKLEtBQUs0QixFQUFFLEdBQUc7Z0JBQzVDcEIsSUFBSXFCLElBQUk7WUFDVjtZQUVBckIsSUFBSWlCLFNBQVM7WUFDYmpCLElBQUlrQixTQUFTLEdBQUdSLE9BQU9oQixLQUFLO1lBQzVCTSxJQUFJbUIsR0FBRyxDQUFDL0IsR0FBR0MsR0FBR3FCLE9BQU9kLElBQUksRUFBRSxHQUFHSixLQUFLNEIsRUFBRSxHQUFHO1lBQ3hDcEIsSUFBSXFCLElBQUk7WUFFUmQsZUFBZWUsSUFBSSxDQUFDWjtRQUN0QjtRQUVBL0IsV0FBV0UsT0FBTyxHQUFHMEI7SUFDdkIsR0FBRztRQUFDL0I7S0FBVztJQUVmLE9BQU87UUFDTEU7UUFDQW1CO1FBQ0FqQjtRQUNBRTtRQUNBd0IsU0FBUzNCLFdBQVdFLE9BQU87SUFDN0I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9OZXVyYWxQYXJ0aWNsZVN5c3RlbS9ob29rcy91c2VEYXRhVHJhbnNmZXIudHM/ZTI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIERhdGFQYWNrZXQge1xyXG4gIHNvdXJjZUluZGV4OiBudW1iZXI7XHJcbiAgdGFyZ2V0SW5kZXg6IG51bWJlcjtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHByb2dyZXNzOiBudW1iZXI7XHJcbiAgc3BlZWQ6IG51bWJlcjtcclxuICBjb2xvcjogc3RyaW5nO1xyXG4gIHNpemU6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZURhdGFUcmFuc2ZlclByb3BzIHtcclxuICBlbmFibGVkOiBib29sZWFuO1xyXG4gIGVuYWJsZUdsb3c6IGJvb2xlYW47XHJcbiAgdGhlbWVDb2xvcnM6IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURhdGFUcmFuc2Zlcih7XHJcbiAgZW5hYmxlZCxcclxuICBlbmFibGVHbG93LFxyXG4gIHRoZW1lQ29sb3JzXHJcbn06IFVzZURhdGFUcmFuc2ZlclByb3BzKSB7XHJcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBwYWNrZXRzUmVmID0gdXNlUmVmPERhdGFQYWNrZXRbXT4oW10pO1xyXG4gIFxyXG4gIGNvbnN0IGluaXREYXRhVHJhbnNmZXIgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBwYWNrZXRzUmVmLmN1cnJlbnQgPSBbXTtcclxuICB9LCBbXSk7XHJcbiAgXHJcbiAgY29uc3QgY3JlYXRlRGF0YVBhY2tldCA9IHVzZUNhbGxiYWNrKChcclxuICAgIHNvdXJjZUluZGV4OiBudW1iZXIsXHJcbiAgICB0YXJnZXRJbmRleDogbnVtYmVyLFxyXG4gICAgcGFydGljbGVzOiBhbnlbXVxyXG4gICkgPT4ge1xyXG4gICAgY29uc3Qgc291cmNlID0gcGFydGljbGVzW3NvdXJjZUluZGV4XTtcclxuICAgIGNvbnN0IHRhcmdldCA9IHBhcnRpY2xlc1t0YXJnZXRJbmRleF07XHJcbiAgICBcclxuICAgIGlmICghc291cmNlIHx8ICF0YXJnZXQpIHJldHVybiBudWxsO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzb3VyY2VJbmRleCxcclxuICAgICAgdGFyZ2V0SW5kZXgsXHJcbiAgICAgIHg6IHNvdXJjZS54LFxyXG4gICAgICB5OiBzb3VyY2UueSxcclxuICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgIHNwZWVkOiBNYXRoLnJhbmRvbSgpICogMC4wMiArIDAuMDEsXHJcbiAgICAgIGNvbG9yOiB0aGVtZUNvbG9ycy5kYXRhIHx8ICcjMDBmZjAwJywgIC8vIEZhbGxiYWNrIHRvIGRlZmF1bHQgZ3JlZW4gaWYgZGF0YSBjb2xvciBpcyB1bmRlZmluZWRcclxuICAgICAgc2l6ZTogTWF0aC5yYW5kb20oKSAqIDEuNSArIDFcclxuICAgIH07XHJcbiAgfSwgW3RoZW1lQ29sb3JzXSk7XHJcbiAgXHJcbiAgY29uc3QgdXBkYXRlRGF0YVRyYW5zZmVyID0gdXNlQ2FsbGJhY2soKGRlbHRhVGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcclxuICAgIGlmICghY2FudmFzKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRydWUgfSk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNhbnZhcztcclxuICAgIFxyXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIFxyXG4gICAgY29uc3QgcGFja2V0cyA9IHBhY2tldHNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IHVwZGF0ZWRQYWNrZXRzOiBEYXRhUGFja2V0W10gPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XHJcbiAgICAgIFxyXG4gICAgICBwYWNrZXQucHJvZ3Jlc3MgKz0gcGFja2V0LnNwZWVkICogZGVsdGFUaW1lICogNjA7XHJcbiAgICAgIFxyXG4gICAgICBpZiAocGFja2V0LnByb2dyZXNzID49IDEpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU2ltcGxpZmllZCBiZXppZXIgY3VydmUgY2FsY3VsYXRpb24gZm9yIGV4YW1wbGVcclxuICAgICAgY29uc3QgdCA9IHBhY2tldC5wcm9ncmVzcztcclxuICAgICAgY29uc3QgeCA9IHBhY2tldC54ICsgdCAqIDEwMDsgLy8gU2ltcGxpZmllZCBtb3ZlbWVudFxyXG4gICAgICBjb25zdCB5ID0gcGFja2V0LnkgKyB0ICogMTAwOyAvLyBTaW1wbGlmaWVkIG1vdmVtZW50XHJcbiAgICAgIFxyXG4gICAgICAvLyBEcmF3IHBhY2tldCB3aXRoIGdsb3dcclxuICAgICAgaWYgKGVuYWJsZUdsb3cpIHtcclxuICAgICAgICBjb25zdCBnbG93R3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXHJcbiAgICAgICAgICB4LCB5LCAwLFxyXG4gICAgICAgICAgeCwgeSwgcGFja2V0LnNpemUgKiA1XHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBnbG93R3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHBhY2tldC5jb2xvci5pbmNsdWRlcygncmdiJykgXHJcbiAgICAgICAgICA/IHBhY2tldC5jb2xvci5yZXBsYWNlKCcpJywgJywgMC41KScpLnJlcGxhY2UoJ3JnYicsICdyZ2JhJylcclxuICAgICAgICAgIDogYCR7cGFja2V0LmNvbG9yfTgwYCk7XHJcbiAgICAgICAgZ2xvd0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBwYWNrZXQuY29sb3IuaW5jbHVkZXMoJ3JnYicpXHJcbiAgICAgICAgICA/IHBhY2tldC5jb2xvci5yZXBsYWNlKCcpJywgJywgMCknKS5yZXBsYWNlKCdyZ2InLCAncmdiYScpXHJcbiAgICAgICAgICA6IGAke3BhY2tldC5jb2xvcn0wMGApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ2xvd0dyYWRpZW50O1xyXG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcGFja2V0LnNpemUgKiA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gcGFja2V0LmNvbG9yO1xyXG4gICAgICBjdHguYXJjKHgsIHksIHBhY2tldC5zaXplLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgIFxyXG4gICAgICB1cGRhdGVkUGFja2V0cy5wdXNoKHBhY2tldCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHBhY2tldHNSZWYuY3VycmVudCA9IHVwZGF0ZWRQYWNrZXRzO1xyXG4gIH0sIFtlbmFibGVHbG93XSk7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGNhbnZhc1JlZixcclxuICAgIHVwZGF0ZURhdGFUcmFuc2ZlcixcclxuICAgIGluaXREYXRhVHJhbnNmZXIsXHJcbiAgICBjcmVhdGVEYXRhUGFja2V0LFxyXG4gICAgcGFja2V0czogcGFja2V0c1JlZi5jdXJyZW50XHJcbiAgfTtcclxufSJdLCJuYW1lcyI6WyJ1c2VSZWYiLCJ1c2VDYWxsYmFjayIsInVzZURhdGFUcmFuc2ZlciIsImVuYWJsZWQiLCJlbmFibGVHbG93IiwidGhlbWVDb2xvcnMiLCJjYW52YXNSZWYiLCJwYWNrZXRzUmVmIiwiaW5pdERhdGFUcmFuc2ZlciIsImN1cnJlbnQiLCJjcmVhdGVEYXRhUGFja2V0Iiwic291cmNlSW5kZXgiLCJ0YXJnZXRJbmRleCIsInBhcnRpY2xlcyIsInNvdXJjZSIsInRhcmdldCIsIngiLCJ5IiwicHJvZ3Jlc3MiLCJzcGVlZCIsIk1hdGgiLCJyYW5kb20iLCJjb2xvciIsImRhdGEiLCJzaXplIiwidXBkYXRlRGF0YVRyYW5zZmVyIiwiZGVsdGFUaW1lIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImFscGhhIiwid2lkdGgiLCJoZWlnaHQiLCJjbGVhclJlY3QiLCJwYWNrZXRzIiwidXBkYXRlZFBhY2tldHMiLCJpIiwibGVuZ3RoIiwicGFja2V0IiwidCIsImdsb3dHcmFkaWVudCIsImNyZWF0ZVJhZGlhbEdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiaW5jbHVkZXMiLCJyZXBsYWNlIiwiYmVnaW5QYXRoIiwiZmlsbFN0eWxlIiwiYXJjIiwiUEkiLCJmaWxsIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useDataTransfer.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useMatrixEffect.ts":
/*!**********************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/hooks/useMatrixEffect.ts ***!
  \**********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useMatrixEffect: function() { return /* binding */ useMatrixEffect; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=useCallback,useRef!=!react */ \"(app-pages-browser)/__barrel_optimize__?names=useCallback,useRef!=!./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ useMatrixEffect auto */ \nfunction useMatrixEffect(param) {\n    let { enabled, density, flowDirection, themeColors } = param;\n    const canvasRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const fragmentsRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const matrixChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=<>[]{}|~^%#@!?;:,.ΨΦΩαβγδεζηθικλμνξπρστυφχψω∞∫∂∇∑∏√∛∜∝∞\".split(\"\");\n    const createFragment = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(width) {\n        let yOffset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        return {\n            x: Math.random() * width,\n            y: flowDirection === \"up\" ? width + yOffset : -Math.random() * 50 - yOffset,\n            speed: Math.random() * 2 + 1,\n            char: matrixChars[Math.floor(Math.random() * matrixChars.length)],\n            opacity: Math.random() * 0.5 + 0.3,\n            lifespan: Math.random() * 200 + 100,\n            age: 0\n        };\n    }, [\n        flowDirection,\n        matrixChars\n    ]);\n    const initMatrix = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((width, height)=>{\n        const count = Math.min(Math.floor(density * width / 1920), 120);\n        const fragments = [];\n        for(let i = 0; i < count; i++){\n            fragments.push(createFragment(width));\n        }\n        fragmentsRef.current = fragments;\n    }, [\n        density,\n        createFragment\n    ]);\n    const updateMatrix = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((deltaTime)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\", {\n            alpha: true\n        });\n        if (!ctx) return;\n        const { width, height } = canvas;\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.05)\";\n        ctx.fillRect(0, 0, width, height);\n        const fragments = fragmentsRef.current;\n        const updatedFragments = [];\n        for(let i = 0; i < fragments.length; i++){\n            const fragment = fragments[i];\n            fragment.age += deltaTime * 60;\n            if (fragment.age > fragment.lifespan) {\n                continue;\n            }\n            let updatedY = fragment.y;\n            if (flowDirection === \"up\") {\n                updatedY -= fragment.speed * deltaTime * 60;\n            } else if (flowDirection === \"down\") {\n                updatedY += fragment.speed * deltaTime * 60;\n            } else {\n                updatedY += (Math.random() > 0.5 ? 1 : -1) * fragment.speed * deltaTime * 60;\n            }\n            if (updatedY < -20 || updatedY > height + 20) {\n                continue;\n            }\n            const lifecycleRatio = fragment.age / fragment.lifespan;\n            let opacity = fragment.opacity;\n            if (lifecycleRatio < 0.2) {\n                opacity *= lifecycleRatio * 5;\n            } else if (lifecycleRatio > 0.8) {\n                opacity *= 1 - (lifecycleRatio - 0.8) * 5;\n            }\n            ctx.font = '14px \"JetBrains Mono\", monospace';\n            ctx.fillStyle = \"\".concat(themeColors.primary).concat(Math.floor(opacity * 255).toString(16).padStart(2, \"0\"));\n            ctx.fillText(fragment.char, fragment.x, updatedY);\n            const newChar = Math.random() < 0.05 ? matrixChars[Math.floor(Math.random() * matrixChars.length)] : fragment.char;\n            updatedFragments.push({\n                ...fragment,\n                y: updatedY,\n                char: newChar\n            });\n        }\n        const targetCount = Math.min(Math.floor(density * width / 1920), 100);\n        while(updatedFragments.length < targetCount){\n            updatedFragments.push(createFragment(width));\n        }\n        fragmentsRef.current = updatedFragments;\n    }, [\n        flowDirection,\n        density,\n        themeColors,\n        matrixChars,\n        createFragment\n    ]);\n    const addMatrixFragments = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((x, y, count)=>{\n        for(let i = 0; i < count; i++){\n            fragmentsRef.current.push({\n                x: x + (Math.random() - 0.5) * 100,\n                y,\n                speed: Math.random() * 3 + 2,\n                char: matrixChars[Math.floor(Math.random() * matrixChars.length)],\n                opacity: Math.random() * 0.7 + 0.5,\n                lifespan: Math.random() * 150 + 50,\n                age: 0\n            });\n        }\n    }, [\n        matrixChars\n    ]);\n    return {\n        canvasRef,\n        updateMatrix,\n        initMatrix,\n        addMatrixFragments\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2hvb2tzL3VzZU1hdHJpeEVmZmVjdC50cyIsIm1hcHBpbmdzIjoiOzs7OztxRUFFNEM7QUFtQnJDLFNBQVNFLGdCQUFnQixLQUtUO1FBTFMsRUFDOUJDLE9BQU8sRUFDUEMsT0FBTyxFQUNQQyxhQUFhLEVBQ2JDLFdBQVcsRUFDVSxHQUxTO0lBTTlCLE1BQU1DLFlBQVlQLHVGQUFNQSxDQUFvQjtJQUM1QyxNQUFNUSxlQUFlUix1RkFBTUEsQ0FBaUIsRUFBRTtJQUU5QyxNQUFNUyxjQUFjLG9HQUFvR0MsS0FBSyxDQUFDO0lBRTlILE1BQU1DLGlCQUFpQlYsNEZBQVdBLENBQUMsU0FBQ1c7WUFBZUMsMkVBQVU7UUFDM0QsT0FBTztZQUNMQyxHQUFHQyxLQUFLQyxNQUFNLEtBQUtKO1lBQ25CSyxHQUFHWixrQkFBa0IsT0FDakJPLFFBQVFDLFVBQ1IsQ0FBQ0UsS0FBS0MsTUFBTSxLQUFLLEtBQUtIO1lBQzFCSyxPQUFPSCxLQUFLQyxNQUFNLEtBQUssSUFBSTtZQUMzQkcsTUFBTVYsV0FBVyxDQUFDTSxLQUFLSyxLQUFLLENBQUNMLEtBQUtDLE1BQU0sS0FBS1AsWUFBWVksTUFBTSxFQUFFO1lBQ2pFQyxTQUFTUCxLQUFLQyxNQUFNLEtBQUssTUFBTTtZQUMvQk8sVUFBVVIsS0FBS0MsTUFBTSxLQUFLLE1BQU07WUFDaENRLEtBQUs7UUFDUDtJQUNGLEdBQUc7UUFBQ25CO1FBQWVJO0tBQVk7SUFFL0IsTUFBTWdCLGFBQWF4Qiw0RkFBV0EsQ0FBQyxDQUFDVyxPQUFlYztRQUM3QyxNQUFNQyxRQUFRWixLQUFLYSxHQUFHLENBQUNiLEtBQUtLLEtBQUssQ0FBQ2hCLFVBQVVRLFFBQVEsT0FBTztRQUMzRCxNQUFNaUIsWUFBNEIsRUFBRTtRQUVwQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUgsT0FBT0csSUFBSztZQUM5QkQsVUFBVUUsSUFBSSxDQUFDcEIs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LElBQUksR0FBR0EsSUFBSUgsT0FBT0csSUFBSztZQUM5QnRCLGFBQWF3QixPQUFPLENBQUNELElBQUksQ0FBQztnQkFDeEJqQixHQUFHQSxJQUFJLENBQUNDLEtBQUtDLE1BQU0sS0FBSyxHQUFFLElBQUs7Z0JBQy9CQztnQkFDQUMsT0FBT0gsS0FBS0MsTUFBTSxLQUFLLElBQUk7Z0JBQzNCRyxNQUFNVixXQUFXLENBQUNNLEtBQUtLLEtBQUssQ0FBQ0wsS0FBS0MsTUFBTSxLQUFLUCxZQUFZWSxNQUFNLEVBQUU7Z0JBQ2pFQyxTQUFTUCxLQUFLQyxNQUFNLEtBQUssTUFBTTtnQkFDL0JPLFVBQVVSLEtBQUtDLE1BQU0sS0FBSyxNQUFNO2dCQUNoQ1EsS0FBSztZQUNQO1FBQ0Y7SUFDRixHQUFHO1FBQUNmO0tBQVk7SUFFaEIsT0FBTztRQUNMRjtRQUNBMEI7UUFDQVI7UUFDQTJCO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9OZXVyYWxQYXJ0aWNsZVN5c3RlbS9ob29rcy91c2VNYXRyaXhFZmZlY3QudHM/NzdmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIENvZGVGcmFnbWVudCB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICBzcGVlZDogbnVtYmVyO1xyXG4gIGNoYXI6IHN0cmluZztcclxuICBvcGFjaXR5OiBudW1iZXI7XHJcbiAgbGlmZXNwYW46IG51bWJlcjtcclxuICBhZ2U6IG51bWJlcjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZU1hdHJpeEVmZmVjdFByb3BzIHtcclxuICBlbmFibGVkOiBib29sZWFuO1xyXG4gIGRlbnNpdHk6IG51bWJlcjtcclxuICBmbG93RGlyZWN0aW9uOiAnZG93bicgfCAndXAnIHwgJ3JhbmRvbSc7XHJcbiAgdGhlbWVDb2xvcnM6IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hdHJpeEVmZmVjdCh7XHJcbiAgZW5hYmxlZCxcclxuICBkZW5zaXR5LFxyXG4gIGZsb3dEaXJlY3Rpb24sXHJcbiAgdGhlbWVDb2xvcnNcclxufTogVXNlTWF0cml4RWZmZWN0UHJvcHMpIHtcclxuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWY8SFRNTENhbnZhc0VsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IGZyYWdtZW50c1JlZiA9IHVzZVJlZjxDb2RlRnJhZ21lbnRbXT4oW10pO1xyXG4gIFxyXG4gIGNvbnN0IG1hdHJpeENoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODkkKy0qLz08Pltde318fl4lI0AhPzs6LC7OqM6mzqnOsc6yzrPOtM61zrbOt864zrnOus67zrzOvc6+z4DPgc+Dz4TPhc+Gz4fPiM+J4oie4oir4oiC4oiH4oiR4oiP4oia4oib4oic4oid4oieXCIuc3BsaXQoJycpO1xyXG4gIFxyXG4gIGNvbnN0IGNyZWF0ZUZyYWdtZW50ID0gdXNlQ2FsbGJhY2soKHdpZHRoOiBudW1iZXIsIHlPZmZzZXQgPSAwKSA9PiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBNYXRoLnJhbmRvbSgpICogd2lkdGgsXHJcbiAgICAgIHk6IGZsb3dEaXJlY3Rpb24gPT09ICd1cCcgXHJcbiAgICAgICAgPyB3aWR0aCArIHlPZmZzZXRcclxuICAgICAgICA6IC1NYXRoLnJhbmRvbSgpICogNTAgLSB5T2Zmc2V0LFxyXG4gICAgICBzcGVlZDogTWF0aC5yYW5kb20oKSAqIDIgKyAxLFxyXG4gICAgICBjaGFyOiBtYXRyaXhDaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXRyaXhDaGFycy5sZW5ndGgpXSxcclxuICAgICAgb3BhY2l0eTogTWF0aC5yYW5kb20oKSAqIDAuNSArIDAuMyxcclxuICAgICAgbGlmZXNwYW46IE1hdGgucmFuZG9tKCkgKiAyMDAgKyAxMDAsXHJcbiAgICAgIGFnZTogMFxyXG4gICAgfTtcclxuICB9LCBbZmxvd0RpcmVjdGlvbiwgbWF0cml4Q2hhcnNdKTtcclxuICBcclxuICBjb25zdCBpbml0TWF0cml4ID0gdXNlQ2FsbGJhY2soKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKE1hdGguZmxvb3IoZGVuc2l0eSAqIHdpZHRoIC8gMTkyMCksIDEyMCk7XHJcbiAgICBjb25zdCBmcmFnbWVudHM6IENvZGVGcmFnbWVudFtdID0gW107XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBmcmFnbWVudHMucHVzaChjcmVhdGVGcmFnbWVudCh3aWR0aCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBmcmFnbWVudHNSZWYuY3VycmVudCA9IGZyYWdtZW50cztcclxuICB9LCBbZGVuc2l0eSwgY3JlYXRlRnJhZ21lbnRdKTtcclxuICBcclxuICBjb25zdCB1cGRhdGVNYXRyaXggPSB1c2VDYWxsYmFjaygoZGVsdGFUaW1lOiBudW1iZXIpID0+IHtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuICAgIFxyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJywgeyBhbHBoYTogdHJ1ZSB9KTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzO1xyXG4gICAgXHJcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4wNSknO1xyXG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgXHJcbiAgICBjb25zdCBmcmFnbWVudHMgPSBmcmFnbWVudHNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IHVwZGF0ZWRGcmFnbWVudHM6IENvZGVGcmFnbWVudFtdID0gW107XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGZyYWdtZW50ID0gZnJhZ21lbnRzW2ldO1xyXG4gICAgICBcclxuICAgICAgZnJhZ21lbnQuYWdlICs9IGRlbHRhVGltZSAqIDYwO1xyXG4gICAgICBcclxuICAgICAgaWYgKGZyYWdtZW50LmFnZSA+IGZyYWdtZW50LmxpZmVzcGFuKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCB1cGRhdGVkWSA9IGZyYWdtZW50Lnk7XHJcbiAgICAgIGlmIChmbG93RGlyZWN0aW9uID09PSAndXAnKSB7XHJcbiAgICAgICAgdXBkYXRlZFkgLT0gZnJhZ21lbnQuc3BlZWQgKiBkZWx0YVRpbWUgKiA2MDtcclxuICAgICAgfSBlbHNlIGlmIChmbG93RGlyZWN0aW9uID09PSAnZG93bicpIHtcclxuICAgICAgICB1cGRhdGVkWSArPSBmcmFnbWVudC5zcGVlZCAqIGRlbHRhVGltZSAqIDYwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVwZGF0ZWRZICs9IChNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xKSAqIGZyYWdtZW50LnNwZWVkICogZGVsdGFUaW1lICogNjA7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICh1cGRhdGVkWSA8IC0yMCB8fCB1cGRhdGVkWSA+IGhlaWdodCArIDIwKSB7XHJcbiAgICAgICAgY29udGludWU7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGxpZmVjeWNsZVJhdGlvID0gZnJhZ21lbnQuYWdlIC8gZnJhZ21lbnQubGlmZXNwYW47XHJcbiAgICAgIGxldCBvcGFjaXR5ID0gZnJhZ21lbnQub3BhY2l0eTtcclxuICAgICAgXHJcbiAgICAgIGlmIChsaWZlY3ljbGVSYXRpbyA8IDAuMikge1xyXG4gICAgICAgIG9wYWNpdHkgKj0gbGlmZWN5Y2xlUmF0aW8gKiA1O1xyXG4gICAgICB9IGVsc2UgaWYgKGxpZmVjeWNsZVJhdGlvID4gMC44KSB7XHJcbiAgICAgICAgb3BhY2l0eSAqPSAoMSAtIChsaWZlY3ljbGVSYXRpbyAtIDAuOCkgKiA1KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY3R4LmZvbnQgPSAnMTRweCBcIkpldEJyYWlucyBNb25vXCIsIG1vbm9zcGFjZSc7XHJcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBgJHt0aGVtZUNvbG9ycy5wcmltYXJ5fSR7TWF0aC5mbG9vcihvcGFjaXR5ICogMjU1KS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX1gO1xyXG4gICAgICBjdHguZmlsbFRleHQoZnJhZ21lbnQuY2hhciwgZnJhZ21lbnQueCwgdXBkYXRlZFkpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgbmV3Q2hhciA9IE1hdGgucmFuZG9tKCkgPCAwLjA1XHJcbiAgICAgICAgPyBtYXRyaXhDaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXRyaXhDaGFycy5sZW5ndGgpXVxyXG4gICAgICAgIDogZnJhZ21lbnQuY2hhcjtcclxuICAgICAgXHJcbiAgICAgIHVwZGF0ZWRGcmFnbWVudHMucHVzaCh7XHJcbiAgICAgICAgLi4uZnJhZ21lbnQsXHJcbiAgICAgICAgeTogdXBkYXRlZFksXHJcbiAgICAgICAgY2hhcjogbmV3Q2hhclxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgdGFyZ2V0Q291bnQgPSBNYXRoLm1pbihNYXRoLmZsb29yKGRlbnNpdHkgKiB3aWR0aCAvIDE5MjApLCAxMDApO1xyXG4gICAgXHJcbiAgICB3aGlsZSAodXBkYXRlZEZyYWdtZW50cy5sZW5ndGggPCB0YXJnZXRDb3VudCkge1xyXG4gICAgICB1cGRhdGVkRnJhZ21lbnRzLnB1c2goY3JlYXRlRnJhZ21lbnQod2lkdGgpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnJhZ21lbnRzUmVmLmN1cnJlbnQgPSB1cGRhdGVkRnJhZ21lbnRzO1xyXG4gIH0sIFtmbG93RGlyZWN0aW9uLCBkZW5zaXR5LCB0aGVtZUNvbG9ycywgbWF0cml4Q2hhcnMsIGNyZWF0ZUZyYWdtZW50XSk7XHJcbiAgXHJcbiAgY29uc3QgYWRkTWF0cml4RnJhZ21lbnRzID0gdXNlQ2FsbGJhY2soKHg6IG51bWJlciwgeTogbnVtYmVyLCBjb3VudDogbnVtYmVyKSA9PiB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgZnJhZ21lbnRzUmVmLmN1cnJlbnQucHVzaCh7XHJcbiAgICAgICAgeDogeCArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwMCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIHNwZWVkOiBNYXRoLnJhbmRvbSgpICogMyArIDIsXHJcbiAgICAgICAgY2hhcjogbWF0cml4Q2hhcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF0cml4Q2hhcnMubGVuZ3RoKV0sXHJcbiAgICAgICAgb3BhY2l0eTogTWF0aC5yYW5kb20oKSAqIDAuNyArIDAuNSxcclxuICAgICAgICBsaWZlc3BhbjogTWF0aC5yYW5kb20oKSAqIDE1MCArIDUwLFxyXG4gICAgICAgIGFnZTogMFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9LCBbbWF0cml4Q2hhcnNdKTtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgY2FudmFzUmVmLFxyXG4gICAgdXBkYXRlTWF0cml4LFxyXG4gICAgaW5pdE1hdHJpeCxcclxuICAgIGFkZE1hdHJpeEZyYWdtZW50c1xyXG4gIH07XHJcbn0iXSwibmFtZXMiOlsidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VNYXRyaXhFZmZlY3QiLCJlbmFibGVkIiwiZGVuc2l0eSIsImZsb3dEaXJlY3Rpb24iLCJ0aGVtZUNvbG9ycyIsImNhbnZhc1JlZiIsImZyYWdtZW50c1JlZiIsIm1hdHJpeENoYXJzIiwic3BsaXQiLCJjcmVhdGVGcmFnbWVudCIsIndpZHRoIiwieU9mZnNldCIsIngiLCJNYXRoIiwicmFuZG9tIiwieSIsInNwZWVkIiwiY2hhciIsImZsb29yIiwibGVuZ3RoIiwib3BhY2l0eSIsImxpZmVzcGFuIiwiYWdlIiwiaW5pdE1hdHJpeCIsImhlaWdodCIsImNvdW50IiwibWluIiwiZnJhZ21lbnRzIiwiaSIsInB1c2giLCJjdXJyZW50IiwidXBkYXRlTWF0cml4IiwiZGVsdGFUaW1lIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImFscGhhIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ1cGRhdGVkRnJhZ21lbnRzIiwiZnJhZ21lbnQiLCJ1cGRhdGVkWSIsImxpZmVjeWNsZVJhdGlvIiwiZm9udCIsInByaW1hcnkiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwiZmlsbFRleHQiLCJuZXdDaGFyIiwidGFyZ2V0Q291bnQiLCJhZGRNYXRyaXhGcmFnbWVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useMatrixEffect.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useNeuralParticles.ts":
/*!*************************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/hooks/useNeuralParticles.ts ***!
  \*************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useNeuralParticles: function() { return /* binding */ useNeuralParticles; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=useCallback,useRef!=!react */ \"(app-pages-browser)/__barrel_optimize__?names=useCallback,useRef!=!./node_modules/next/dist/compiled/react/index.js\");\n/* __next_internal_client_entry_do_not_use__ useNeuralParticles auto */ \nfunction useNeuralParticles(param) {\n    let { density, connectDistance, pulseNodes, enableGlow, themeColors } = param;\n    const canvasRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const particlesRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const mouseRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        x: 0,\n        y: 0,\n        active: false\n    });\n    const frameCountRef = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n    const initParticles = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((width, height)=>{\n        const scaleFactor = width * height / (1920 * 1080);\n        const scaledDensity = Math.max(Math.floor(density * scaleFactor), 20);\n        const count = Math.min(scaledDensity, 500);\n        const particles = [];\n        for(let i = 0; i < count; i++){\n            const isNeuron = Math.random() < 0.15;\n            particles.push({\n                x: Math.random() * width,\n                y: Math.random() * height,\n                vx: (Math.random() - 0.5) * (isNeuron ? 0.2 : 0.5),\n                vy: (Math.random() - 0.5) * (isNeuron ? 0.2 : 0.5),\n                radius: isNeuron ? Math.random() * 3 + 2 : Math.random() * 1.5 + 0.5,\n                color: isNeuron ? themeColors.primary : themeColors.secondary,\n                opacity: isNeuron ? Math.random() * 0.3 + 0.7 : Math.random() * 0.4 + 0.2,\n                isNeuron,\n                pulseRate: Math.random() * 0.02 + 0.01,\n                pulsePhase: Math.random() * Math.PI * 2,\n                connections: [],\n                dataTransfer: isNeuron ? {\n                    active: false,\n                    progress: 0,\n                    speed: 0,\n                    targetNodeIndex: -1\n                } : undefined\n            });\n        }\n        particlesRef.current = particles;\n    }, [\n        density,\n        themeColors\n    ]);\n    const updateParticles = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((deltaTime)=>{\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const { width, height } = canvas;\n        ctx.clearRect(0, 0, width, height);\n        const particles = particlesRef.current;\n        const len = particles.length;\n        // Update connections every 3 frames for performance\n        if (frameCountRef.current % 3 === 0) {\n            for(let i = 0; i < len; i++){\n                particles[i].connections = [];\n                for(let j = i + 1; j < len; j++){\n                    const dx = particles[j].x - particles[i].x;\n                    const dy = particles[j].y - particles[i].y;\n                    const distSquared = dx * dx + dy * dy;\n                    const maxDistSquared = particles[i].isNeuron || particles[j].isNeuron ? connectDistance * connectDistance * 2.25 : connectDistance * connectDistance;\n                    if (distSquared < maxDistSquared) {\n                        particles[i].connections.push(j);\n                    }\n                }\n            }\n        }\n        // Update and draw particles\n        for(let i = 0; i < len; i++){\n            const p = particles[i];\n            // Update position\n            p.x += p.vx * deltaTime * 60;\n            p.y += p.vy * deltaTime * 60;\n            // Boundary checks\n            if (p.x - p.radius <= 0 || p.x + p.radius >= width) {\n                p.vx = -p.vx;\n                p.x = Math.max(p.radius, Math.min(width - p.radius, p.x));\n            }\n            if (p.y - p.radius <= 0 || p.y + p.radius >= height) {\n                p.vy = -p.vy;\n                p.y = Math.max(p.radius, Math.min(height - p.radius, p.y));\n            }\n            // Draw connections\n            for (const j of p.connections){\n                const p2 = particles[j];\n                const dx = p2.x - p.x;\n                const dy = p2.y - p.y;\n                const distance = Math.sqrt(dx * dx + dy * dy);\n                const maxDistance = p.isNeuron || p2.isNeuron ? connectDistance * 1.5 : connectDistance;\n                let lineOpacity = 0.2 * (1 - distance / maxDistance);\n                if (p.isNeuron && p2.isNeuron) {\n                    lineOpacity *= 1.5;\n                }\n                const gradient = ctx.createLinearGradient(p.x, p.y, p2.x, p2.y);\n                gradient.addColorStop(0, \"\".concat(p.color.replace(\")\", \", \".concat(lineOpacity, \")\"))));\n                gradient.addColorStop(1, \"\".concat(p2.color.replace(\")\", \", \".concat(lineOpacity, \")\"))));\n                ctx.beginPath();\n                ctx.strokeStyle = gradient;\n                ctx.lineWidth = p.isNeuron && p2.isNeuron ? 0.5 : 0.3;\n                ctx.moveTo(p.x, p.y);\n                ctx.lineTo(p2.x, p2.y);\n                ctx.stroke();\n            }\n            // Draw particle\n            let displayRadius = p.radius;\n            let currentOpacity = p.opacity;\n            if (p.isNeuron && pulseNodes) {\n                const pulse = Math.sin(Date.now() * p.pulseRate + p.pulsePhase);\n                displayRadius = p.radius * (1 + 0.2 * pulse);\n                currentOpacity = p.opacity * (0.8 + 0.2 * pulse);\n            }\n            if (p.isNeuron && enableGlow) {\n                const glowSize = displayRadius * 8;\n                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize);\n                gradient.addColorStop(0, p.color.replace(\")\", \", \".concat(currentOpacity * 0.4, \")\")));\n                gradient.addColorStop(1, p.color.replace(\")\", \", 0)\"));\n                ctx.beginPath();\n                ctx.fillStyle = gradient;\n                ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            ctx.beginPath();\n            ctx.fillStyle = p.color.replace(\")\", \", \".concat(currentOpacity, \")\"));\n            ctx.arc(p.x, p.y, displayRadius, 0, Math.PI * 2);\n            ctx.fill();\n        }\n        frameCountRef.current++;\n    }, [\n        connectDistance,\n        pulseNodes,\n        enableGlow\n    ]);\n    const addParticles = (0,_barrel_optimize_names_useCallback_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((x, y, count)=>{\n        const particles = particlesRef.current;\n        for(let i = 0; i < count; i++){\n            const angle = Math.random() * Math.PI * 2;\n            const speed = Math.random() * 2 + 1;\n            const isNeuron = Math.random() < 0.3;\n            if (particles.length < 500) {\n                particles.push({\n                    x,\n                    y,\n                    vx: Math.cos(angle) * speed * 0.5,\n                    vy: Math.sin(angle) * speed * 0.5,\n                    radius: isNeuron ? Math.random() * 3 + 2 : Math.random() * 1.5 + 0.5,\n                    color: isNeuron ? themeColors.primary : themeColors.secondary,\n                    opacity: isNeuron ? Math.random() * 0.3 + 0.7 : Math.random() * 0.4 + 0.2,\n                    isNeuron,\n                    pulseRate: Math.random() * 0.02 + 0.01,\n                    pulsePhase: Math.random() * Math.PI * 2,\n                    connections: [],\n                    dataTransfer: isNeuron ? {\n                        active: false,\n                        progress: 0,\n                        speed: 0,\n                        targetNodeIndex: -1\n                    } : undefined\n                });\n            }\n        }\n    }, [\n        themeColors\n    ]);\n    return {\n        canvasRef,\n        particles: particlesRef.current,\n        updateParticles,\n        addParticles,\n        initParticles,\n        mouseRef\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2hvb2tzL3VzZU5ldXJhbFBhcnRpY2xlcy50cyIsIm1hcHBpbmdzIjoiOzs7Ozt3RUFFNEM7QUE4QnJDLFNBQVNFLG1CQUFtQixLQU1UO1FBTlMsRUFDakNDLE9BQU8sRUFDUEMsZUFBZSxFQUNmQyxVQUFVLEVBQ1ZDLFVBQVUsRUFDVkMsV0FBVyxFQUNhLEdBTlM7SUFPakMsTUFBTUMsWUFBWVIsdUZBQU1BLENBQW9CO0lBQzVDLE1BQU1TLGVBQWVULHVGQUFNQSxDQUFtQixFQUFFO0lBQ2hELE1BQU1VLFdBQVdWLHVGQUFNQSxDQUFDO1FBQUVXLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxRQUFRO0lBQU07SUFDcEQsTUFBTUMsZ0JBQWdCZCx1RkFBTUEsQ0FBQztJQUU3QixNQUFNZSxnQkFBZ0JkLDRGQUFXQSxDQUFDLENBQUNlLE9BQWVDO1FBQ2hELE1BQU1DLGNBQWMsUUFBU0QsU0FBVyxRQUFPLElBQUc7UUFDbEQsTUFBTUUsZ0JBQWdCQyxLQUFLQyxHQUFHLENBQUNELEtBQUtFLEtBQUssQ0FBQ25CLFVBQVVlLGNBQWM7UUFDbEUsTUFBTUssUUFBUUgsS0FBS0ksR0FBRyxDQUFDTCxlQUFlO1FBRXRDLE1BQU1NLFlBQThCLEVBQUU7UUFFdEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlILE9BQU9HLElBQUs7WUFDOUIsTUFBTUMsV0FBV1AsS0FBS1EsTUFBTSxLQUFLO1lBRWpDSCxVQUFVSSxJQUFJLENBQUM7Z0JBQ2JsQixHQUFHUyxLQUFLUSxNQUFNLEtBQUtaO2dCQUNuQkosR0FBR1EsS0FBS1EsTUFBTSxLQUFLWDtnQkFDbkJhLElBQUksQ0FBQ1YsS0FBS1EsTUFBTSxLQUFLLEdBQUUsSUFBTUQsQ0FBQUEsV0FBVyxNQUFNLEdBQUU7Z0JBQ2hESSxJQUFJLENBQUNYLEtBQUtRLE1BQU0sS0FBSyxHQUFFLElBQU1ELENBQUFBLFdBQVcsTUFBTSxH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N0IsVUFBVUksSUFBSSxDQUFDO29CQUNibEI7b0JBQ0FDO29CQUNBa0IsSUFBSVYsS0FBS3FFLEdBQUcsQ0FBQ0QsU0FBUzdDLFFBQVE7b0JBQzlCWixJQUFJWCxLQUFLMkQsR0FBRyxDQUFDUyxTQUFTN0MsUUFBUTtvQkFDOUJYLFFBQVFMLFdBQVdQLEtBQUtRLE1BQU0sS0FBSyxJQUFJLElBQUlSLEtBQUtRLE1BQU0sS0FBSyxNQUFNO29CQUNqRUssT0FBT04sV0FBV3BCLFlBQVkyQixPQUFPLEdBQUczQixZQUFZNEIsU0FBUztvQkFDN0RDLFNBQVNULFdBQVdQLEtBQUtRLE1BQU0sS0FBSyxNQUFNLE1BQU1SLEtBQUtRLE1BQU0sS0FBSyxNQUFNO29CQUN0RUQ7b0JBQ0FVLFdBQVdqQixLQUFLUSxNQUFNLEtBQUssT0FBTztvQkFDbENVLFlBQVlsQixLQUFLUSxNQUFNLEtBQUtSLEtBQUttQixFQUFFLEdBQUc7b0JBQ3RDQyxhQUFhLEVBQUU7b0JBQ2ZDLGNBQWNkLFdBQVc7d0JBQ3ZCZCxRQUFRO3dCQUNSNkIsVUFBVTt3QkFDVkMsT0FBTzt3QkFDUEMsaUJBQWlCLENBQUM7b0JBQ3BCLElBQUlDO2dCQUNOO1lBQ0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ3RDO0tBQVk7SUFFaEIsT0FBTztRQUNMQztRQUNBaUIsV0FBV2hCLGFBQWFxQyxPQUFPO1FBQy9CQztRQUNBd0M7UUFDQXhFO1FBQ0FMO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9OZXVyYWxQYXJ0aWNsZVN5c3RlbS9ob29rcy91c2VOZXVyYWxQYXJ0aWNsZXMudHM/NmYzNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIE5ldXJhbFBhcnRpY2xlIHtcclxuICB4OiBudW1iZXI7XHJcbiAgeTogbnVtYmVyO1xyXG4gIHZ4OiBudW1iZXI7XHJcbiAgdnk6IG51bWJlcjtcclxuICByYWRpdXM6IG51bWJlcjtcclxuICBjb2xvcjogc3RyaW5nO1xyXG4gIG9wYWNpdHk6IG51bWJlcjtcclxuICBpc05ldXJvbjogYm9vbGVhbjtcclxuICBwdWxzZVJhdGU6IG51bWJlcjtcclxuICBwdWxzZVBoYXNlOiBudW1iZXI7XHJcbiAgY29ubmVjdGlvbnM6IG51bWJlcltdO1xyXG4gIGRhdGFUcmFuc2Zlcj86IHtcclxuICAgIGFjdGl2ZTogYm9vbGVhbjtcclxuICAgIHByb2dyZXNzOiBudW1iZXI7XHJcbiAgICBzcGVlZDogbnVtYmVyO1xyXG4gICAgdGFyZ2V0Tm9kZUluZGV4OiBudW1iZXI7XHJcbiAgfTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFVzZU5ldXJhbFBhcnRpY2xlc1Byb3BzIHtcclxuICBkZW5zaXR5OiBudW1iZXI7XHJcbiAgY29ubmVjdERpc3RhbmNlOiBudW1iZXI7XHJcbiAgcHVsc2VOb2RlczogYm9vbGVhbjtcclxuICBlbmFibGVHbG93OiBib29sZWFuO1xyXG4gIHRoZW1lQ29sb3JzOiBhbnk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VOZXVyYWxQYXJ0aWNsZXMoe1xyXG4gIGRlbnNpdHksXHJcbiAgY29ubmVjdERpc3RhbmNlLFxyXG4gIHB1bHNlTm9kZXMsXHJcbiAgZW5hYmxlR2xvdyxcclxuICB0aGVtZUNvbG9yc1xyXG59OiBVc2VOZXVyYWxQYXJ0aWNsZXNQcm9wcykge1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgcGFydGljbGVzUmVmID0gdXNlUmVmPE5ldXJhbFBhcnRpY2xlW10+KFtdKTtcclxuICBjb25zdCBtb3VzZVJlZiA9IHVzZVJlZih7IHg6IDAsIHk6IDAsIGFjdGl2ZTogZmFsc2UgfSk7XHJcbiAgY29uc3QgZnJhbWVDb3VudFJlZiA9IHVzZVJlZigwKTtcclxuICBcclxuICBjb25zdCBpbml0UGFydGljbGVzID0gdXNlQ2FsbGJhY2soKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9ICh3aWR0aCAqIGhlaWdodCkgLyAoMTkyMCAqIDEwODApO1xyXG4gICAgY29uc3Qgc2NhbGVkRGVuc2l0eSA9IE1hdGgubWF4KE1hdGguZmxvb3IoZGVuc2l0eSAqIHNjYWxlRmFjdG9yKSwgMjApO1xyXG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihzY2FsZWREZW5zaXR5LCA1MDApO1xyXG4gICAgXHJcbiAgICBjb25zdCBwYXJ0aWNsZXM6IE5ldXJhbFBhcnRpY2xlW10gPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGlzTmV1cm9uID0gTWF0aC5yYW5kb20oKSA8IDAuMTU7XHJcbiAgICAgIFxyXG4gICAgICBwYXJ0aWNsZXMucHVzaCh7XHJcbiAgICAgICAgeDogTWF0aC5yYW5kb20oKSAqIHdpZHRoLFxyXG4gICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiBoZWlnaHQsXHJcbiAgICAgICAgdng6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIChpc05ldXJvbiA/IDAuMiA6IDAuNSksXHJcbiAgICAgICAgdnk6IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIChpc05ldXJvbiA/IDAuMiA6IDAuNSksXHJcbiAgICAgICAgcmFkaXVzOiBpc05ldXJvbiA/IE1hdGgucmFuZG9tKCkgKiAzICsgMiA6IE1hdGgucmFuZG9tKCkgKiAxLjUgKyAwLjUsXHJcbiAgICAgICAgY29sb3I6IGlzTmV1cm9uID8gdGhlbWVDb2xvcnMucHJpbWFyeSA6IHRoZW1lQ29sb3JzLnNlY29uZGFyeSxcclxuICAgICAgICBvcGFjaXR5OiBpc05ldXJvbiA/IE1hdGgucmFuZG9tKCkgKiAwLjMgKyAwLjcgOiBNYXRoLnJhbmRvbSgpICogMC40ICsgMC4yLFxyXG4gICAgICAgIGlzTmV1cm9uLFxyXG4gICAgICAgIHB1bHNlUmF0ZTogTWF0aC5yYW5kb20oKSAqIDAuMDIgKyAwLjAxLFxyXG4gICAgICAgIHB1bHNlUGhhc2U6IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcclxuICAgICAgICBjb25uZWN0aW9uczogW10sXHJcbiAgICAgICAgZGF0YVRyYW5zZmVyOiBpc05ldXJvbiA/IHtcclxuICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgIHNwZWVkOiAwLFxyXG4gICAgICAgICAgdGFyZ2V0Tm9kZUluZGV4OiAtMVxyXG4gICAgICAgIH0gOiB1bmRlZmluZWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50ID0gcGFydGljbGVzO1xyXG4gIH0sIFtkZW5zaXR5LCB0aGVtZUNvbG9yc10pO1xyXG4gIFxyXG4gIGNvbnN0IHVwZGF0ZVBhcnRpY2xlcyA9IHVzZUNhbGxiYWNrKChkZWx0YVRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgIGlmICghY3R4KSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY2FudmFzO1xyXG4gICAgXHJcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgXHJcbiAgICBjb25zdCBwYXJ0aWNsZXMgPSBwYXJ0aWNsZXNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGxlbiA9IHBhcnRpY2xlcy5sZW5ndGg7XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBjb25uZWN0aW9ucyBldmVyeSAzIGZyYW1lcyBmb3IgcGVyZm9ybWFuY2VcclxuICAgIGlmIChmcmFtZUNvdW50UmVmLmN1cnJlbnQgJSAzID09PSAwKSB7XHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBwYXJ0aWNsZXNbaV0uY29ubmVjdGlvbnMgPSBbXTtcclxuICAgICAgICBcclxuICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBsZW47IGorKykge1xyXG4gICAgICAgICAgY29uc3QgZHggPSBwYXJ0aWNsZXNbal0ueCAtIHBhcnRpY2xlc1tpXS54O1xyXG4gICAgICAgICAgY29uc3QgZHkgPSBwYXJ0aWNsZXNbal0ueSAtIHBhcnRpY2xlc1tpXS55O1xyXG4gICAgICAgICAgY29uc3QgZGlzdFNxdWFyZWQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgbWF4RGlzdFNxdWFyZWQgPSAocGFydGljbGVzW2ldLmlzTmV1cm9uIHx8IHBhcnRpY2xlc1tqXS5pc05ldXJvbikgXHJcbiAgICAgICAgICAgID8gY29ubmVjdERpc3RhbmNlICogY29ubmVjdERpc3RhbmNlICogMi4yNSBcclxuICAgICAgICAgICAgOiBjb25uZWN0RGlzdGFuY2UgKiBjb25uZWN0RGlzdGFuY2U7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1heERpc3RTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgIHBhcnRpY2xlc1tpXS5jb25uZWN0aW9ucy5wdXNoKGopO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgYW5kIGRyYXcgcGFydGljbGVzXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IHAgPSBwYXJ0aWNsZXNbaV07XHJcbiAgICAgIFxyXG4gICAgICAvLyBVcGRhdGUgcG9zaXRpb25cclxuICAgICAgcC54ICs9IHAudnggKiBkZWx0YVRpbWUgKiA2MDtcclxuICAgICAgcC55ICs9IHAudnkgKiBkZWx0YVRpbWUgKiA2MDtcclxuICAgICAgXHJcbiAgICAgIC8vIEJvdW5kYXJ5IGNoZWNrc1xyXG4gICAgICBpZiAocC54IC0gcC5yYWRpdXMgPD0gMCB8fCBwLnggKyBwLnJhZGl1cyA+PSB3aWR0aCkge1xyXG4gICAgICAgIHAudnggPSAtcC52eDtcclxuICAgICAgICBwLnggPSBNYXRoLm1heChwLnJhZGl1cywgTWF0aC5taW4od2lkdGggLSBwLnJhZGl1cywgcC54KSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHAueSAtIHAucmFkaXVzIDw9IDAgfHwgcC55ICsgcC5yYWRpdXMgPj0gaGVpZ2h0KSB7XHJcbiAgICAgICAgcC52eSA9IC1wLnZ5O1xyXG4gICAgICAgIHAueSA9IE1hdGgubWF4KHAucmFkaXVzLCBNYXRoLm1pbihoZWlnaHQgLSBwLnJhZGl1cywgcC55KSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIERyYXcgY29ubmVjdGlvbnNcclxuICAgICAgZm9yIChjb25zdCBqIG9mIHAuY29ubmVjdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBwMiA9IHBhcnRpY2xlc1tqXTtcclxuICAgICAgICBjb25zdCBkeCA9IHAyLnggLSBwLng7XHJcbiAgICAgICAgY29uc3QgZHkgPSBwMi55IC0gcC55O1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBtYXhEaXN0YW5jZSA9IChwLmlzTmV1cm9uIHx8IHAyLmlzTmV1cm9uKSBcclxuICAgICAgICAgID8gY29ubmVjdERpc3RhbmNlICogMS41IFxyXG4gICAgICAgICAgOiBjb25uZWN0RGlzdGFuY2U7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGxpbmVPcGFjaXR5ID0gMC4yICogKDEgLSBkaXN0YW5jZSAvIG1heERpc3RhbmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocC5pc05ldXJvbiAmJiBwMi5pc05ldXJvbikge1xyXG4gICAgICAgICAgbGluZU9wYWNpdHkgKj0gMS41O1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwLngsIHAueSwgcDIueCwgcDIueSk7XHJcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGAke3AuY29sb3IucmVwbGFjZSgnKScsIGAsICR7bGluZU9wYWNpdHl9KWApfWApO1xyXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBgJHtwMi5jb2xvci5yZXBsYWNlKCcpJywgYCwgJHtsaW5lT3BhY2l0eX0pYCl9YCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdyYWRpZW50O1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBwLmlzTmV1cm9uICYmIHAyLmlzTmV1cm9uID8gMC41IDogMC4zO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8ocC54LCBwLnkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBEcmF3IHBhcnRpY2xlXHJcbiAgICAgIGxldCBkaXNwbGF5UmFkaXVzID0gcC5yYWRpdXM7XHJcbiAgICAgIGxldCBjdXJyZW50T3BhY2l0eSA9IHAub3BhY2l0eTtcclxuICAgICAgXHJcbiAgICAgIGlmIChwLmlzTmV1cm9uICYmIHB1bHNlTm9kZXMpIHtcclxuICAgICAgICBjb25zdCBwdWxzZSA9IE1hdGguc2luKERhdGUubm93KCkgKiBwLnB1bHNlUmF0ZSArIHAucHVsc2VQaGFzZSk7XHJcbiAgICAgICAgZGlzcGxheVJhZGl1cyA9IHAucmFkaXVzICogKDEgKyAwLjIgKiBwdWxzZSk7XHJcbiAgICAgICAgY3VycmVudE9wYWNpdHkgPSBwLm9wYWNpdHkgKiAoMC44ICsgMC4yICogcHVsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAocC5pc05ldXJvbiAmJiBlbmFibGVHbG93KSB7XHJcbiAgICAgICAgY29uc3QgZ2xvd1NpemUgPSBkaXNwbGF5UmFkaXVzICogODtcclxuICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcclxuICAgICAgICAgIHAueCwgcC55LCAwLFxyXG4gICAgICAgICAgcC54LCBwLnksIGdsb3dTaXplXHJcbiAgICAgICAgKTtcclxuICAgICAgICBcclxuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgcC5jb2xvci5yZXBsYWNlKCcpJywgYCwgJHtjdXJyZW50T3BhY2l0eSAqIDAuNH0pYCkpO1xyXG4gICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBwLmNvbG9yLnJlcGxhY2UoJyknLCAnLCAwKScpKTtcclxuICAgICAgICBcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xyXG4gICAgICAgIGN0eC5hcmMocC54LCBwLnksIGdsb3dTaXplLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICBjdHguZmlsbFN0eWxlID0gcC5jb2xvci5yZXBsYWNlKCcpJywgYCwgJHtjdXJyZW50T3BhY2l0eX0pYCk7XHJcbiAgICAgIGN0eC5hcmMocC54LCBwLnksIGRpc3BsYXlSYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgZnJhbWVDb3VudFJlZi5jdXJyZW50Kys7XHJcbiAgfSwgW2Nvbm5lY3REaXN0YW5jZSwgcHVsc2VOb2RlcywgZW5hYmxlR2xvd10pO1xyXG4gIFxyXG4gIGNvbnN0IGFkZFBhcnRpY2xlcyA9IHVzZUNhbGxiYWNrKCh4OiBudW1iZXIsIHk6IG51bWJlciwgY291bnQ6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgcGFydGljbGVzID0gcGFydGljbGVzUmVmLmN1cnJlbnQ7XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcclxuICAgICAgY29uc3Qgc3BlZWQgPSBNYXRoLnJhbmRvbSgpICogMiArIDE7XHJcbiAgICAgIGNvbnN0IGlzTmV1cm9uID0gTWF0aC5yYW5kb20oKSA8IDAuMztcclxuICAgICAgXHJcbiAgICAgIGlmIChwYXJ0aWNsZXMubGVuZ3RoIDwgNTAwKSB7XHJcbiAgICAgICAgcGFydGljbGVzLnB1c2goe1xyXG4gICAgICAgICAgeCxcclxuICAgICAgICAgIHksXHJcbiAgICAgICAgICB2eDogTWF0aC5jb3MoYW5nbGUpICogc3BlZWQgKiAwLjUsXHJcbiAgICAgICAgICB2eTogTWF0aC5zaW4oYW5nbGUpICogc3BlZWQgKiAwLjUsXHJcbiAgICAgICAgICByYWRpdXM6IGlzTmV1cm9uID8gTWF0aC5yYW5kb20oKSAqIDMgKyAyIDogTWF0aC5yYW5kb20oKSAqIDEuNSArIDAuNSxcclxuICAgICAgICAgIGNvbG9yOiBpc05ldXJvbiA/IHRoZW1lQ29sb3JzLnByaW1hcnkgOiB0aGVtZUNvbG9ycy5zZWNvbmRhcnksXHJcbiAgICAgICAgICBvcGFjaXR5OiBpc05ldXJvbiA/IE1hdGgucmFuZG9tKCkgKiAwLjMgKyAwLjcgOiBNYXRoLnJhbmRvbSgpICogMC40ICsgMC4yLFxyXG4gICAgICAgICAgaXNOZXVyb24sXHJcbiAgICAgICAgICBwdWxzZVJhdGU6IE1hdGgucmFuZG9tKCkgKiAwLjAyICsgMC4wMSxcclxuICAgICAgICAgIHB1bHNlUGhhc2U6IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcclxuICAgICAgICAgIGNvbm5lY3Rpb25zOiBbXSxcclxuICAgICAgICAgIGRhdGFUcmFuc2ZlcjogaXNOZXVyb24gPyB7XHJcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByb2dyZXNzOiAwLFxyXG4gICAgICAgICAgICBzcGVlZDogMCxcclxuICAgICAgICAgICAgdGFyZ2V0Tm9kZUluZGV4OiAtMVxyXG4gICAgICAgICAgfSA6IHVuZGVmaW5lZFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSwgW3RoZW1lQ29sb3JzXSk7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGNhbnZhc1JlZixcclxuICAgIHBhcnRpY2xlczogcGFydGljbGVzUmVmLmN1cnJlbnQsXHJcbiAgICB1cGRhdGVQYXJ0aWNsZXMsXHJcbiAgICBhZGRQYXJ0aWNsZXMsXHJcbiAgICBpbml0UGFydGljbGVzLFxyXG4gICAgbW91c2VSZWZcclxuICB9O1xyXG59Il0sIm5hbWVzIjpbInVzZVJlZiIsInVzZUNhbGxiYWNrIiwidXNlTmV1cmFsUGFydGljbGVzIiwiZGVuc2l0eSIsImNvbm5lY3REaXN0YW5jZSIsInB1bHNlTm9kZXMiLCJlbmFibGVHbG93IiwidGhlbWVDb2xvcnMiLCJjYW52YXNSZWYiLCJwYXJ0aWNsZXNSZWYiLCJtb3VzZVJlZiIsIngiLCJ5IiwiYWN0aXZlIiwiZnJhbWVDb3VudFJlZiIsImluaXRQYXJ0aWNsZXMiLCJ3aWR0aCIsImhlaWdodCIsInNjYWxlRmFjdG9yIiwic2NhbGVkRGVuc2l0eSIsIk1hdGgiLCJtYXgiLCJmbG9vciIsImNvdW50IiwibWluIiwicGFydGljbGVzIiwiaSIsImlzTmV1cm9uIiwicmFuZG9tIiwicHVzaCIsInZ4IiwidnkiLCJyYWRpdXMiLCJjb2xvciIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJvcGFjaXR5IiwicHVsc2VSYXRlIiwicHVsc2VQaGFzZSIsIlBJIiwiY29ubmVjdGlvbnMiLCJkYXRhVHJhbnNmZXIiLCJwcm9ncmVzcyIsInNwZWVkIiwidGFyZ2V0Tm9kZUluZGV4IiwidW5kZWZpbmVkIiwiY3VycmVudCIsInVwZGF0ZVBhcnRpY2xlcyIsImRlbHRhVGltZSIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJsZW4iLCJsZW5ndGgiLCJqIiwiZHgiLCJkeSIsImRpc3RTcXVhcmVkIiwibWF4RGlzdFNxdWFyZWQiLCJwIiwicDIiLCJkaXN0YW5jZSIsInNxcnQiLCJtYXhEaXN0YW5jZSIsImxpbmVPcGFjaXR5IiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInJlcGxhY2UiLCJiZWdpblBhdGgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImRpc3BsYXlSYWRpdXMiLCJjdXJyZW50T3BhY2l0eSIsInB1bHNlIiwic2luIiwiRGF0ZSIsIm5vdyIsImdsb3dTaXplIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJmaWxsU3R5bGUiLCJhcmMiLCJmaWxsIiwiYWRkUGFydGljbGVzIiwiYW5nbGUiLCJjb3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/hooks/useNeuralParticles.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/index.ts":
/*!******************************************************!*\
  !*** ./src/components/NeuralParticleSystem/index.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _NeuralParticleSystem__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _NeuralParticleSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NeuralParticleSystem */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2luZGV4LnRzP2VkYzMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTmV1cmFsUGFydGljbGVTeXN0ZW0nO1xyXG5cclxuZXhwb3J0IHR5cGUge1xyXG4gIE5ldXJhbFBhcnRpY2xlU3lzdGVtUHJvcHMsXHJcbiAgTmV1cmFsUGFydGljbGUsXHJcbiAgRGF0YVBhY2tldCxcclxuICBDb2RlRnJhZ21lbnRcclxufSBmcm9tICcuL05ldXJhbFBhcnRpY2xlU3lzdGVtJzsiXSwibmFtZXMiOlsiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/index.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useAnimationFrame.ts":
/*!****************************************!*\
  !*** ./src/hooks/useAnimationFrame.ts ***!
  \****************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAnimationFrame: function() { return /* binding */ useAnimationFrame; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_useCallback_useEffect_useRef_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=useCallback,useEffect,useRef!=!react */ \"(app-pages-browser)/__barrel_optimize__?names=useCallback,useEffect,useRef!=!./node_modules/next/dist/compiled/react/index.js\");\n// src/hooks/useAnimationFrame.ts\n\nconst useAnimationFrame = (callback)=>{\n    const requestRef = (0,_barrel_optimize_names_useCallback_useEffect_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const previousTimeRef = (0,_barrel_optimize_names_useCallback_useEffect_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    const isRunningRef = (0,_barrel_optimize_names_useCallback_useEffect_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const animate = (0,_barrel_optimize_names_useCallback_useEffect_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((time)=>{\n        if (previousTimeRef.current !== undefined) {\n            const deltaTime = time - previousTimeRef.current;\n            // Cap deltaTime to prevent large jumps when tab becomes active\n            const cappedDeltaTime = Math.min(deltaTime, 32); // ~30fps minimum\n            if (isRunningRef.current) {\n                callback(cappedDeltaTime / 1000); // Convert to seconds\n            }\n        }\n        previousTimeRef.current = time;\n        requestRef.current = requestAnimationFrame(animate);\n    }, [\n        callback\n    ]);\n    (0,_barrel_optimize_names_useCallback_useEffect_useRef_react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        requestRef.current = requestAnimationFrame(animate);\n        const handleVisibilityChange = ()=>{\n            isRunningRef.current = !document.hidden;\n            if (isRunningRef.current) {\n                // Reset time when becoming visible to prevent large delta\n                previousTimeRef.current = undefined;\n            }\n        };\n        document.addEventListener(\"visibilitychange\", handleVisibilityChange);\n        return ()=>{\n            if (requestRef.current) {\n                cancelAnimationFrame(requestRef.current);\n            }\n            document.removeEventListener(\"visibilitychange\", handleVisibilityChange);\n        };\n    }, [\n        animate\n    ]);\n    return {\n        pause: ()=>{\n            isRunningRef.current = false;\n        },\n        resume: ()=>{\n            isRunningRef.current = true;\n        },\n        isRunning: ()=>isRunningRef.current\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VBbmltYXRpb25GcmFtZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlDQUFpQztBQUNzQjtBQUVoRCxNQUFNRyxvQkFBb0IsQ0FBQ0M7SUFDaEMsTUFBTUMsYUFBYUwsaUdBQU1BO0lBQ3pCLE1BQU1NLGtCQUFrQk4saUdBQU1BO0lBQzlCLE1BQU1PLGVBQWVQLGlHQUFNQSxDQUFVO0lBRXJDLE1BQU1RLFVBQVVOLHNHQUFXQSxDQUFDLENBQUNPO1FBQzNCLElBQUlILGdCQUFnQkksT0FBTyxLQUFLQyxXQUFXO1lBQ3pDLE1BQU1DLFlBQVlILE9BQU9ILGdCQUFnQkksT0FBTztZQUVoRCwrREFBK0Q7WUFDL0QsTUFBTUcsa0JBQWtCQyxLQUFLQyxHQUFHLENBQUNILFdBQVcsS0FBSyxpQkFBaUI7WUFFbEUsSUFBSUwsYUFBYUcsT0FBTyxFQUFFO2dCQUN4Qk4sU0FBU1Msa0JBQWtCLE9BQU8scUJBQXFCO1lBQ3pEO1FBQ0Y7UUFFQVAsZ0JBQWdCSSxPQUFPLEdBQUdEO1FBQzFCSixXQUFXSyxPQUFPLEdBQUdNLHNCQUFzQlI7SUFDN0MsR0FBRztRQUFDSjtLQUFTO0lBRWJILG9HQUFTQSxDQUFDO1FBQ1JJLFdBQVdLLE9BQU8sR0FBR00sc0JBQXNCUjtRQUUzQyxNQUFNUyx5QkFBeUI7WUFDN0JWLGFBQWFHLE9BQU8sR0FBRyxDQUFDUSxTQUFTQyxNQUFNO1lBRXZDLElBQUlaLGFBQWFHLE9BQU8sRUFBRTtnQkFDeEIsMERBQTBEO2dCQUMxREosZ0JBQWdCSSxPQUFPLEdBQUdDO1lBQzVCO1FBQ0Y7UUFFQU8sU0FBU0UsZ0JBQWdCLENBQUMsb0JBQW9CSDtRQUU5QyxPQUFPO1lBQ0wsSUFBSVosV0FBV0ssT0FBTyxFQUFFO2dCQUN0QlcscUJBQXFCaEIsV0FBV0ssT0FBTztZQUN6QztZQUNBUSxTQUFTSSxtQkFBbUIsQ0FBQyxvQkFBb0JMO1FBQ25EO0lBQ0YsR0FBRztRQUFDVDtLQUFRO0lBRVosT0FBTztRQUNMZSxPQUFPO1lBQVFoQixhQUFhRyxPQUFPLEdBQUc7UUFBTztRQUM3Q2MsUUFBUTtZQUFRakIsYUFBYUcsT0FBTyxHQUFHO1FBQU07UUFDN0NlLFdBQVcsSUFBTWxCLGFBQWFHLE9BQU87SUFDdkM7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9ob29rcy91c2VBbmltYXRpb25GcmFtZS50cz9jMTA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9ob29rcy91c2VBbmltYXRpb25GcmFtZS50c1xyXG5pbXBvcnQgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XHJcblxyXG5leHBvcnQgY29uc3QgdXNlQW5pbWF0aW9uRnJhbWUgPSAoY2FsbGJhY2s6IChkZWx0YVRpbWU6IG51bWJlcikgPT4gdm9pZCkgPT4ge1xyXG4gIGNvbnN0IHJlcXVlc3RSZWYgPSB1c2VSZWY8bnVtYmVyPigpO1xyXG4gIGNvbnN0IHByZXZpb3VzVGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KCk7XHJcbiAgY29uc3QgaXNSdW5uaW5nUmVmID0gdXNlUmVmPGJvb2xlYW4+KHRydWUpO1xyXG4gIFxyXG4gIGNvbnN0IGFuaW1hdGUgPSB1c2VDYWxsYmFjaygodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICBpZiAocHJldmlvdXNUaW1lUmVmLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aW1lIC0gcHJldmlvdXNUaW1lUmVmLmN1cnJlbnQ7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDYXAgZGVsdGFUaW1lIHRvIHByZXZlbnQgbGFyZ2UganVtcHMgd2hlbiB0YWIgYmVjb21lcyBhY3RpdmVcclxuICAgICAgY29uc3QgY2FwcGVkRGVsdGFUaW1lID0gTWF0aC5taW4oZGVsdGFUaW1lLCAzMik7IC8vIH4zMGZwcyBtaW5pbXVtXHJcbiAgICAgIFxyXG4gICAgICBpZiAoaXNSdW5uaW5nUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjYWxsYmFjayhjYXBwZWREZWx0YVRpbWUgLyAxMDAwKTsgLy8gQ29udmVydCB0byBzZWNvbmRzXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJldmlvdXNUaW1lUmVmLmN1cnJlbnQgPSB0aW1lO1xyXG4gICAgcmVxdWVzdFJlZi5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gIH0sIFtjYWxsYmFja10pO1xyXG4gIFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICByZXF1ZXN0UmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICBcclxuICAgIGNvbnN0IGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgIGlzUnVubmluZ1JlZi5jdXJyZW50ID0gIWRvY3VtZW50LmhpZGRlbjtcclxuICAgICAgXHJcbiAgICAgIGlmIChpc1J1bm5pbmdSZWYuY3VycmVudCkge1xyXG4gICAgICAgIC8vIFJlc2V0IHRpbWUgd2hlbiBiZWNvbWluZyB2aXNpYmxlIHRvIHByZXZlbnQgbGFyZ2UgZGVsdGFcclxuICAgICAgICBwcmV2aW91c1RpbWVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBpZiAocmVxdWVzdFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxdWVzdFJlZi5jdXJyZW50KTtcclxuICAgICAgfVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSk7XHJcbiAgICB9O1xyXG4gIH0sIFthbmltYXRlXSk7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIHBhdXNlOiAoKSA9PiB7IGlzUnVubmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7IH0sXHJcbiAgICByZXN1bWU6ICgpID0+IHsgaXNSdW5uaW5nUmVmLmN1cnJlbnQgPSB0cnVlOyB9LFxyXG4gICAgaXNSdW5uaW5nOiAoKSA9PiBpc1J1bm5pbmdSZWYuY3VycmVudFxyXG4gIH07XHJcbn07Il0sIm5hbWVzIjpbInVzZVJlZiIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlQW5pbWF0aW9uRnJhbWUiLCJjYWxsYmFjayIsInJlcXVlc3RSZWYiLCJwcmV2aW91c1RpbWVSZWYiLCJpc1J1bm5pbmdSZWYiLCJhbmltYXRlIiwidGltZSIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJkZWx0YVRpbWUiLCJjYXBwZWREZWx0YVRpbWUiLCJNYXRoIiwibWluIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSIsImRvY3VtZW50IiwiaGlkZGVuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInBhdXNlIiwicmVzdW1lIiwiaXNSdW5uaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useAnimationFrame.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/hooks/useThemeColors.ts":
/*!*************************************!*\
  !*** ./src/hooks/useThemeColors.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useThemeColors: function() { return /* binding */ useThemeColors; }\n/* harmony export */ });\n/* harmony import */ var _barrel_optimize_names_useMemo_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! __barrel_optimize__?names=useMemo!=!react */ \"(app-pages-browser)/__barrel_optimize__?names=useMemo!=!./node_modules/next/dist/compiled/react/index.js\");\n// src/hooks/useThemeColors.ts\n\nfunction useThemeColors(colorScheme) {\n    return (0,_barrel_optimize_names_useMemo_react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const themes = {\n            green: {\n                primary: \"#00ff00\",\n                secondary: \"#00cc44\",\n                tertiary: \"#003300\",\n                accent: \"#33ff33\",\n                background: \"#001100\",\n                data: \"#ccffcc\",\n                glow: \"rgba(0, 255, 0, 0.7)\"\n            },\n            blue: {\n                primary: \"#0088ff\",\n                secondary: \"#00ccff\",\n                tertiary: \"#000066\",\n                accent: \"#33ccff\",\n                background: \"#000033\",\n                data: \"#ccf5ff\",\n                glow: \"rgba(0, 136, 255, 0.7)\"\n            },\n            purple: {\n                primary: \"#aa00ff\",\n                secondary: \"#cc66ff\",\n                tertiary: \"#330066\",\n                accent: \"#dd99ff\",\n                background: \"#110022\",\n                data: \"#eeccff\",\n                glow: \"rgba(170, 0, 255, 0.7)\"\n            },\n            red: {\n                primary: \"#ff3311\",\n                secondary: \"#ff6644\",\n                tertiary: \"#660000\",\n                accent: \"#ff9977\",\n                background: \"#110000\",\n                data: \"#ffcccc\",\n                glow: \"rgba(255, 51, 17, 0.7)\"\n            },\n            cyan: {\n                primary: \"#00ffff\",\n                secondary: \"#66ffff\",\n                tertiary: \"#006666\",\n                accent: \"#99ffff\",\n                background: \"#001111\",\n                data: \"#ccffff\",\n                glow: \"rgba(0, 255, 255, 0.7)\"\n            },\n            multi: {\n                primary: \"#00ff00\",\n                secondary: \"#00ccff\",\n                tertiary: \"#aa00ff\",\n                accent: \"#ff3311\",\n                background: \"#000022\",\n                data: \"#ffffff\",\n                glow: \"rgba(0, 255, 102, 0.7)\"\n            }\n        };\n        return themes[colorScheme] || themes.green;\n    }, [\n        colorScheme\n    ]);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9ob29rcy91c2VUaGVtZUNvbG9ycy50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLDhCQUE4QjtBQUNFO0FBRXpCLFNBQVNDLGVBQWVDLFdBQW1CO0lBQ2hELE9BQU9GLDZFQUFPQSxDQUFDO1FBQ2IsTUFBTUcsU0FBUztZQUNiQyxPQUFPO2dCQUNMQyxTQUFTO2dCQUNUQyxXQUFXO2dCQUNYQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFDQUMsTUFBTTtnQkFDSlAsU0FBUztnQkFDVEMsV0FBVztnQkFDWEMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1lBQ0FFLFFBQVE7Z0JBQ05SLFNBQVM7Z0JBQ1RDLFdBQVc7Z0JBQ1hDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtZQUNBRyxLQUFLO2dCQUNIVCxTQUFTO2dCQUNUQyxXQUFXO2dCQUNYQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSQyxZQUFZO2dCQUNaQyxNQUFNO2dCQUNOQyxNQUFNO1lBQ1I7WUFDQUksTUFBTTtnQkFDSlYsU0FBUztnQkFDVEMsV0FBVztnQkFDWEMsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUkMsWUFBWTtnQkFDWkMsTUFBTTtnQkFDTkMsTUFBTTtZQUNSO1lBQ0FLLE9BQU87Z0JBQ0xYLFNBQVM7Z0JBQ1RDLFdBQVc7Z0JBQ1hDLFVBQVU7Z0JBQ1ZDLFFBQVE7Z0JBQ1JDLFlBQVk7Z0JBQ1pDLE1BQU07Z0JBQ05DLE1BQU07WUFDUjtRQUNGO1FBRUEsT0FBT1IsTUFBTSxDQUFDRCxZQUFtQyxJQUFJQyxPQUFPQyxLQUFLO0lBQ25FLEdBQUc7UUFBQ0Y7S0FBWTtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvaG9va3MvdXNlVGhlbWVDb2xvcnMudHM/MWMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaG9va3MvdXNlVGhlbWVDb2xvcnMudHNcclxuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUaGVtZUNvbG9ycyhjb2xvclNjaGVtZTogc3RyaW5nKSB7XHJcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgdGhlbWVzID0ge1xyXG4gICAgICBncmVlbjoge1xyXG4gICAgICAgIHByaW1hcnk6ICcjMDBmZjAwJyxcclxuICAgICAgICBzZWNvbmRhcnk6ICcjMDBjYzQ0JyxcclxuICAgICAgICB0ZXJ0aWFyeTogJyMwMDMzMDAnLFxyXG4gICAgICAgIGFjY2VudDogJyMzM2ZmMzMnLFxyXG4gICAgICAgIGJhY2tncm91bmQ6ICcjMDAxMTAwJyxcclxuICAgICAgICBkYXRhOiAnI2NjZmZjYycsXHJcbiAgICAgICAgZ2xvdzogJ3JnYmEoMCwgMjU1LCAwLCAwLjcpJ1xyXG4gICAgICB9LFxyXG4gICAgICBibHVlOiB7XHJcbiAgICAgICAgcHJpbWFyeTogJyMwMDg4ZmYnLFxyXG4gICAgICAgIHNlY29uZGFyeTogJyMwMGNjZmYnLFxyXG4gICAgICAgIHRlcnRpYXJ5OiAnIzAwMDA2NicsXHJcbiAgICAgICAgYWNjZW50OiAnIzMzY2NmZicsXHJcbiAgICAgICAgYmFja2dyb3VuZDogJyMwMDAwMzMnLFxyXG4gICAgICAgIGRhdGE6ICcjY2NmNWZmJyxcclxuICAgICAgICBnbG93OiAncmdiYSgwLCAxMzYsIDI1NSwgMC43KSdcclxuICAgICAgfSxcclxuICAgICAgcHVycGxlOiB7XHJcbiAgICAgICAgcHJpbWFyeTogJyNhYTAwZmYnLFxyXG4gICAgICAgIHNlY29uZGFyeTogJyNjYzY2ZmYnLFxyXG4gICAgICAgIHRlcnRpYXJ5OiAnIzMzMDA2NicsXHJcbiAgICAgICAgYWNjZW50OiAnI2RkOTlmZicsXHJcbiAgICAgICAgYmFja2dyb3VuZDogJyMxMTAwMjInLFxyXG4gICAgICAgIGRhdGE6ICcjZWVjY2ZmJyxcclxuICAgICAgICBnbG93OiAncmdiYSgxNzAsIDAsIDI1NSwgMC43KSdcclxuICAgICAgfSxcclxuICAgICAgcmVkOiB7XHJcbiAgICAgICAgcHJpbWFyeTogJyNmZjMzMTEnLFxyXG4gICAgICAgIHNlY29uZGFyeTogJyNmZjY2NDQnLFxyXG4gICAgICAgIHRlcnRpYXJ5OiAnIzY2MDAwMCcsXHJcbiAgICAgICAgYWNjZW50OiAnI2ZmOTk3NycsXHJcbiAgICAgICAgYmFja2dyb3VuZDogJyMxMTAwMDAnLFxyXG4gICAgICAgIGRhdGE6ICcjZmZjY2NjJyxcclxuICAgICAgICBnbG93OiAncmdiYSgyNTUsIDUxLCAxNywgMC43KSdcclxuICAgICAgfSxcclxuICAgICAgY3lhbjoge1xyXG4gICAgICAgIHByaW1hcnk6ICcjMDBmZmZmJyxcclxuICAgICAgICBzZWNvbmRhcnk6ICcjNjZmZmZmJyxcclxuICAgICAgICB0ZXJ0aWFyeTogJyMwMDY2NjYnLFxyXG4gICAgICAgIGFjY2VudDogJyM5OWZmZmYnLFxyXG4gICAgICAgIGJhY2tncm91bmQ6ICcjMDAxMTExJyxcclxuICAgICAgICBkYXRhOiAnI2NjZmZmZicsXHJcbiAgICAgICAgZ2xvdzogJ3JnYmEoMCwgMjU1LCAyNTUsIDAuNyknXHJcbiAgICAgIH0sXHJcbiAgICAgIG11bHRpOiB7XHJcbiAgICAgICAgcHJpbWFyeTogJyMwMGZmMDAnLFxyXG4gICAgICAgIHNlY29uZGFyeTogJyMwMGNjZmYnLFxyXG4gICAgICAgIHRlcnRpYXJ5OiAnI2FhMDBmZicsXHJcbiAgICAgICAgYWNjZW50OiAnI2ZmMzMxMScsXHJcbiAgICAgICAgYmFja2dyb3VuZDogJyMwMDAwMjInLFxyXG4gICAgICAgIGRhdGE6ICcjZmZmZmZmJyxcclxuICAgICAgICBnbG93OiAncmdiYSgwLCAyNTUsIDEwMiwgMC43KSdcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHRoZW1lc1tjb2xvclNjaGVtZSBhcyBrZXlvZiB0eXBlb2YgdGhlbWVzXSB8fCB0aGVtZXMuZ3JlZW47XHJcbiAgfSwgW2NvbG9yU2NoZW1lXSk7XHJcbn0iXSwibmFtZXMiOlsidXNlTWVtbyIsInVzZVRoZW1lQ29sb3JzIiwiY29sb3JTY2hlbWUiLCJ0aGVtZXMiLCJncmVlbiIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJ0ZXJ0aWFyeSIsImFjY2VudCIsImJhY2tncm91bmQiLCJkYXRhIiwiZ2xvdyIsImJsdWUiLCJwdXJwbGUiLCJyZWQiLCJjeWFuIiwibXVsdGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/hooks/useThemeColors.ts\n"));

/***/ })

}]);