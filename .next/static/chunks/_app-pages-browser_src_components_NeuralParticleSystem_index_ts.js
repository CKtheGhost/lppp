/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_NeuralParticleSystem_index_ts"],{

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css":
/*!*****************************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css ***!
  \*****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"NeuralParticleSystem_container__JUvux\",\"active\":\"NeuralParticleSystem_active__R988f\",\"green\":\"NeuralParticleSystem_green__LgrW2\",\"blue\":\"NeuralParticleSystem_blue__5N816\",\"purple\":\"NeuralParticleSystem_purple__pA7yk\",\"red\":\"NeuralParticleSystem_red__r8wNa\",\"cyan\":\"NeuralParticleSystem_cyan__VJwMX\",\"multi\":\"NeuralParticleSystem_multi__xJcce\",\"canvas\":\"NeuralParticleSystem_canvas__GZ2mZ\",\"matrixCanvas\":\"NeuralParticleSystem_matrixCanvas__mba2Y\",\"dataCanvas\":\"NeuralParticleSystem_dataCanvas__t7Flg\",\"scanlines\":\"NeuralParticleSystem_scanlines__gwL0L\",\"flicker\":\"NeuralParticleSystem_flicker__mWrFO\",\"subtlePulse\":\"NeuralParticleSystem_subtlePulse__Y_j3M\"};\n    if(true) {\n      // 1745380917325\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  \nmodule.exports.__checksum = \"57a2d7be60b4\"\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL05ldXJhbFBhcnRpY2xlU3lzdGVtLm1vZHVsZS5jc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQkFBa0I7QUFDbEIsT0FBTyxJQUFVO0FBQ2pCO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsd01BQWlJLGNBQWMsc0RBQXNEO0FBQ25PLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvTmV1cmFsUGFydGljbGVTeXN0ZW0vTmV1cmFsUGFydGljbGVTeXN0ZW0ubW9kdWxlLmNzcz9mNTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCJjb250YWluZXJcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2NvbnRhaW5lcl9fSlV2dXhcIixcImFjdGl2ZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fYWN0aXZlX19SOTg4ZlwiLFwiZ3JlZW5cIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2dyZWVuX19MZ3JXMlwiLFwiYmx1ZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fYmx1ZV9fNU44MTZcIixcInB1cnBsZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fcHVycGxlX19wQTd5a1wiLFwicmVkXCI6XCJOZXVyYWxQYXJ0aWNsZVN5c3RlbV9yZWRfX3I4d05hXCIsXCJjeWFuXCI6XCJOZXVyYWxQYXJ0aWNsZVN5c3RlbV9jeWFuX19WSndNWFwiLFwibXVsdGlcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX211bHRpX194SmNjZVwiLFwiY2FudmFzXCI6XCJOZXVyYWxQYXJ0aWNsZVN5c3RlbV9jYW52YXNfX0daMm1aXCIsXCJtYXRyaXhDYW52YXNcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX21hdHJpeENhbnZhc19fbWJhMllcIixcImRhdGFDYW52YXNcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2RhdGFDYW52YXNfX3Q3RmxnXCIsXCJzY2FubGluZXNcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX3NjYW5saW5lc19fZ3dMMExcIixcImZsaWNrZXJcIjpcIk5ldXJhbFBhcnRpY2xlU3lzdGVtX2ZsaWNrZXJfX21XckZPXCIsXCJzdWJ0bGVQdWxzZVwiOlwiTmV1cmFsUGFydGljbGVTeXN0ZW1fc3VidGxlUHVsc2VfX1lfajNNXCJ9O1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIC8vIDE3NDUzODA5MTczMjVcbiAgICAgIHZhciBjc3NSZWxvYWQgPSByZXF1aXJlKFwiQzovVXNlcnMvY2svTGFuZGluZ1Byb3NwZXJhL3Byb3NwZXJhLW5leHRqcy9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgXG5tb2R1bGUuZXhwb3J0cy5fX2NoZWNrc3VtID0gXCI1N2EyZDdiZTYwYjRcIlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx":
/*!**********************************************************************!*\
  !*** ./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx ***!
  \**********************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NeuralParticleSystem.module.css */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.module.css\");\n/* harmony import */ var _NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2__);\n// src/components/NeuralParticleSystem/NeuralParticleSystem.tsx\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst NeuralParticleSystem = (param)=>{\n    let { density = 60, interactive = true, reactToClick = true, connectDistance = 150, colorScheme = \"green\", matrixEffect = true, dataTransferEffect = true, codeFragmentDensity = 30, flowDirection = \"down\", pulseNodes = true, enableGlow = true } = param;\n    _s();\n    // Canvas and container refs\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const matrixCanvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const dataCanvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // State for dimensions\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [isLoaded, setIsLoaded] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isInitialized, setIsInitialized] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Refs for animations and data - using useRef to avoid re-renders\n    const particlesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const dataPacketsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const codeFragmentsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const mouseRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0,\n        active: false\n    });\n    const lastClickRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)({\n        x: 0,\n        y: 0,\n        time: 0\n    });\n    // Animation frame refs\n    const mainAnimationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const matrixAnimationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const dataAnimationRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Matrix characters - memo for performance\n    const matrixChars = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const standardChars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$+-*/=<>[]{}|~^%#@!?;:,.\".split(\"\");\n        const quantumChars = \"ΨΦΩαβγδεζηθικλμνξπρστυφχψω∞∫∂∇∑∏√∛∜∝∞\".split(\"\");\n        return [\n            ...standardChars,\n            ...quantumChars.filter((_, i)=>i % 3 === 0)\n        ];\n    }, []);\n    // Theme colors with enhanced color schemes\n    const themeColors = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const themes = {\n            green: {\n                primary: \"#00ff00\",\n                secondary: \"#00cc44\",\n                tertiary: \"#003300\",\n                accent: \"#33ff33\",\n                background: \"#001100\",\n                data: \"#ccffcc\"\n            },\n            blue: {\n                primary: \"#0088ff\",\n                secondary: \"#00ccff\",\n                tertiary: \"#000066\",\n                accent: \"#33ccff\",\n                background: \"#000033\",\n                data: \"#ccf5ff\"\n            },\n            purple: {\n                primary: \"#aa00ff\",\n                secondary: \"#cc66ff\",\n                tertiary: \"#330066\",\n                accent: \"#dd99ff\",\n                background: \"#110022\",\n                data: \"#eeccff\"\n            },\n            red: {\n                primary: \"#ff3311\",\n                secondary: \"#ff6644\",\n                tertiary: \"#660000\",\n                accent: \"#ff9977\",\n                background: \"#110000\",\n                data: \"#ffcccc\"\n            },\n            cyan: {\n                primary: \"#00ffff\",\n                secondary: \"#66ffff\",\n                tertiary: \"#006666\",\n                accent: \"#99ffff\",\n                background: \"#001111\",\n                data: \"#ccffff\"\n            },\n            multi: {\n                primary: \"#00ff00\",\n                secondary: \"#00ccff\",\n                tertiary: \"#aa00ff\",\n                accent: \"#ff3311\",\n                background: \"#000022\",\n                data: \"#ffffff\"\n            }\n        };\n        return themes;\n    }, []);\n    // Initialize dimensions and listeners\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const updateDimensions = ()=>{\n            if (!containerRef.current) return;\n            const { offsetWidth, offsetHeight } = containerRef.current;\n            // Only update if dimensions actually changed to prevent unnecessary rerenders\n            setDimensions((prevDimensions)=>{\n                if (prevDimensions.width !== offsetWidth || prevDimensions.height !== offsetHeight) {\n                    return {\n                        width: offsetWidth,\n                        height: offsetHeight\n                    };\n                }\n                return prevDimensions;\n            });\n        };\n        // Set initial dimensions\n        updateDimensions();\n        // Debounce resize handler for better performance\n        let resizeTimer;\n        const handleResize = ()=>{\n            clearTimeout(resizeTimer);\n            resizeTimer = setTimeout(updateDimensions, 100);\n        };\n        window.addEventListener(\"resize\", handleResize, {\n            passive: true\n        });\n        return ()=>{\n            window.removeEventListener(\"resize\", handleResize);\n            clearTimeout(resizeTimer);\n        };\n    }, []);\n    // Generate particle color based on chosen scheme - memoized for performance\n    const getParticleColor = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function() {\n        let isNeuron = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;\n        const colors = themeColors[colorScheme];\n        if (colorScheme === \"multi\") {\n            const schemes = [\n                \"green\",\n                \"blue\",\n                \"purple\",\n                \"red\",\n                \"cyan\"\n            ];\n            const randomScheme = schemes[Math.floor(Math.random() * schemes.length)];\n            const schemeColors = themeColors[randomScheme];\n            return isNeuron ? schemeColors.primary : schemeColors.secondary;\n        }\n        return isNeuron ? colors.primary : colors.secondary;\n    }, [\n        colorScheme,\n        themeColors\n    ]);\n    // Initialize particles when dimensions change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (dimensions.width <= 0 || dimensions.height <= 0 || isInitialized) return;\n        // Set canvas sizes with device pixel ratio for crisp rendering\n        const dpr =  true ? window.devicePixelRatio || 1 : 0;\n        // Initialize canvas contexts\n        const updateCanvas = (canvas)=>{\n            if (!canvas) return;\n            canvas.width = dimensions.width * dpr;\n            canvas.height = dimensions.height * dpr;\n            const ctx = canvas.getContext(\"2d\");\n            if (ctx) {\n                ctx.scale(dpr, dpr);\n            }\n        };\n        updateCanvas(canvasRef.current);\n        updateCanvas(matrixCanvasRef.current);\n        updateCanvas(dataCanvasRef.current);\n        // Initialize particles and effects\n        initParticles();\n        if (matrixEffect) {\n            initCodeFragments();\n        }\n        // Mark as initialized\n        setIsInitialized(true);\n        // Set loaded with delay for transition\n        const loadTimer = setTimeout(()=>{\n            setIsLoaded(true);\n        }, 300);\n        return ()=>clearTimeout(loadTimer);\n    }, [\n        dimensions,\n        matrixEffect,\n        isInitialized\n    ]);\n    // Initialize particles\n    const initParticles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const { width, height } = dimensions;\n        // Scale density based on screen size to maintain consistent appearance\n        const scaleFactor = width * height / (1920 * 1080);\n        const scaledDensity = Math.max(Math.floor(density * scaleFactor), 20);\n        const count = Math.min(scaledDensity, 500); // Cap at 500 particles for performance\n        const particles = [];\n        for(let i = 0; i < count; i++){\n            const isNeuron = Math.random() < 0.15; // 15% chance to be a neuron node\n            particles.push({\n                x: Math.random() * width,\n                y: Math.random() * height,\n                vx: (Math.random() - 0.5) * (isNeuron ? 0.2 : 0.5),\n                vy: (Math.random() - 0.5) * (isNeuron ? 0.2 : 0.5),\n                radius: isNeuron ? Math.random() * 3 + 2 : Math.random() * 1.5 + 0.5,\n                color: getParticleColor(isNeuron),\n                opacity: isNeuron ? Math.random() * 0.3 + 0.7 : Math.random() * 0.4 + 0.2,\n                isNeuron,\n                pulseRate: Math.random() * 0.02 + 0.01,\n                pulsePhase: Math.random() * Math.PI * 2,\n                connections: [],\n                dataTransfer: isNeuron ? {\n                    active: false,\n                    progress: 0,\n                    speed: 0,\n                    targetNodeIndex: -1\n                } : undefined\n            });\n        }\n        particlesRef.current = particles;\n    }, [\n        dimensions,\n        density,\n        getParticleColor\n    ]);\n    // Initialize code fragments for matrix effect\n    const initCodeFragments = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        const { width, height } = dimensions;\n        // Scale fragments based on screen width\n        const count = Math.min(Math.floor(codeFragmentDensity * width / 1920), 120);\n        const fragments = [];\n        for(let i = 0; i < count; i++){\n            fragments.push(createCodeFragment(width));\n        }\n        codeFragmentsRef.current = fragments;\n    }, [\n        dimensions,\n        codeFragmentDensity\n    ]);\n    // Create a new code fragment\n    const createCodeFragment = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((width)=>{\n        // Start position based on flow direction\n        const startY = flowDirection === \"up\" ? dimensions.height + Math.random() * 50 : -Math.random() * 50;\n        const fragment = {\n            x: Math.random() * width,\n            y: startY,\n            speed: Math.random() * 2 + 1,\n            char: matrixChars[Math.floor(Math.random() * matrixChars.length)],\n            opacity: Math.random() * 0.5 + 0.3,\n            lifespan: Math.random() * 200 + 100,\n            age: 0\n        };\n        return fragment;\n    }, [\n        dimensions.height,\n        flowDirection,\n        matrixChars\n    ]);\n    // Create a new data packet for transfer between nodes\n    const createDataPacket = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((sourceIndex, targetIndex)=>{\n        const source = particlesRef.current[sourceIndex];\n        const target = particlesRef.current[targetIndex];\n        if (!source || !target) return null;\n        const colors = themeColors[colorScheme];\n        const packet = {\n            sourceIndex,\n            targetIndex,\n            x: source.x,\n            y: source.y,\n            progress: 0,\n            speed: Math.random() * 0.02 + 0.01,\n            color: colors.data,\n            size: Math.random() * 1.5 + 1\n        };\n        return packet;\n    }, [\n        colorScheme,\n        themeColors\n    ]);\n    // Handle mouse movement\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!interactive || !canvasRef.current || !isInitialized) return;\n        const handleMouseMove = (e)=>{\n            var _canvasRef_current;\n            const rect = (_canvasRef_current = canvasRef.current) === null || _canvasRef_current === void 0 ? void 0 : _canvasRef_current.getBoundingClientRect();\n            if (!rect) return;\n            mouseRef.current = {\n                x: e.clientX - rect.left,\n                y: e.clientY - rect.top,\n                active: true\n            };\n        };\n        const handleMouseLeave = ()=>{\n            mouseRef.current.active = false;\n        };\n        const handleClick = (e)=>{\n            if (!reactToClick || !canvasRef.current) return;\n            const rect = canvasRef.current.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Limit click handling rate for better performance\n            const now = Date.now();\n            if (now - lastClickRef.current.time < 300) return; // Debounce clicks\n            // Store click position and time\n            lastClickRef.current = {\n                x,\n                y,\n                time: now\n            };\n            // Create additional particles\n            addParticlesAtPoint(x, y, 5);\n            // Add code fragments at click point\n            if (matrixEffect) {\n                addCodeFragmentsAtPoint(x, y, 10);\n            }\n        };\n        const canvas = canvasRef.current;\n        canvas.addEventListener(\"mousemove\", handleMouseMove, {\n            passive: true\n        });\n        canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n        canvas.addEventListener(\"click\", handleClick);\n        return ()=>{\n            canvas.removeEventListener(\"mousemove\", handleMouseMove);\n            canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n            canvas.removeEventListener(\"click\", handleClick);\n        };\n    }, [\n        interactive,\n        reactToClick,\n        matrixEffect,\n        isInitialized\n    ]);\n    // Add particles at a specific point\n    const addParticlesAtPoint = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((x, y, count)=>{\n        for(let i = 0; i < count; i++){\n            const angle = Math.random() * Math.PI * 2;\n            const speed = Math.random() * 2 + 1;\n            const isNeuron = Math.random() < 0.3; // Higher chance to be a neuron\n            // Cap total particle count to prevent performance issues\n            if (particlesRef.current.length < 500) {\n                particlesRef.current.push({\n                    x,\n                    y,\n                    vx: Math.cos(angle) * speed * 0.5,\n                    vy: Math.sin(angle) * speed * 0.5,\n                    radius: isNeuron ? Math.random() * 3 + 2 : Math.random() * 1.5 + 0.5,\n                    color: getParticleColor(isNeuron),\n                    opacity: isNeuron ? Math.random() * 0.3 + 0.7 : Math.random() * 0.4 + 0.2,\n                    isNeuron,\n                    pulseRate: Math.random() * 0.02 + 0.01,\n                    pulsePhase: Math.random() * Math.PI * 2,\n                    connections: [],\n                    dataTransfer: isNeuron ? {\n                        active: false,\n                        progress: 0,\n                        speed: 0,\n                        targetNodeIndex: -1\n                    } : undefined\n                });\n            }\n        }\n    }, [\n        getParticleColor\n    ]);\n    // Add code fragments at a specific point\n    const addCodeFragmentsAtPoint = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((x, y, count)=>{\n        for(let i = 0; i < count; i++){\n            const fragment = {\n                x: x + (Math.random() - 0.5) * 100,\n                y,\n                speed: Math.random() * 3 + 2,\n                char: matrixChars[Math.floor(Math.random() * matrixChars.length)],\n                opacity: Math.random() * 0.7 + 0.5,\n                lifespan: Math.random() * 150 + 50,\n                age: 0\n            };\n            codeFragmentsRef.current.push(fragment);\n        }\n    }, [\n        matrixChars\n    ]);\n    // Main animation loop for particles and connections\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!canvasRef.current || !isInitialized || dimensions.width <= 0) return;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        let frameCount = 0;\n        let lastTimestamp = 0;\n        const animate = (timestamp)=>{\n            // Calculate delta time for smooth animations regardless of frame rate\n            const deltaTime = lastTimestamp ? (timestamp - lastTimestamp) / 16.667 : 1;\n            lastTimestamp = timestamp;\n            // Clear canvas\n            ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n            // Only recompute connections every few frames for performance\n            const shouldComputeConnections = frameCount % 3 === 0;\n            if (shouldComputeConnections) {\n                // Reset connections\n                particlesRef.current.forEach((p)=>{\n                    p.connections = [];\n                });\n                // Compute connections - quadratic operation, so we optimize it\n                const particles = particlesRef.current;\n                const len = particles.length;\n                for(let i = 0; i < len; i++){\n                    const p = particles[i];\n                    for(let j = i + 1; j < len; j++){\n                        const p2 = particles[j];\n                        const dx = p2.x - p.x;\n                        const dy = p2.y - p.y;\n                        // Using squared distance to avoid square root operation\n                        const distSquared = dx * dx + dy * dy;\n                        // Set connection distance based on whether it's a neuron\n                        const connectionDistanceSquared = p.isNeuron || p2.isNeuron ? connectDistance * connectDistance * 2.25 // 1.5^2\n                         : connectDistance * connectDistance;\n                        if (distSquared < connectionDistanceSquared) {\n                            p.connections.push(j);\n                            // Randomly activate data transfer between neurons\n                            if (dataTransferEffect && p.isNeuron && p2.isNeuron && Math.random() < 0.001) {\n                                if (p.dataTransfer && !p.dataTransfer.active) {\n                                    p.dataTransfer.active = true;\n                                    p.dataTransfer.progress = 0;\n                                    p.dataTransfer.speed = Math.random() * 0.02 + 0.01;\n                                    p.dataTransfer.targetNodeIndex = j;\n                                    // Create data packet\n                                    const packet = createDataPacket(i, j);\n                                    if (packet) {\n                                        dataPacketsRef.current.push(packet);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // Update and draw particles\n            const particles = particlesRef.current;\n            const len = particles.length;\n            for(let i = 0; i < len; i++){\n                const p = particles[i];\n                // Update position with delta time for consistent movement\n                p.x += p.vx * deltaTime;\n                p.y += p.vy * deltaTime;\n                // Boundary checks with bounce\n                if (p.x - p.radius <= 0 || p.x + p.radius >= dimensions.width) {\n                    p.vx = -p.vx;\n                    // Clamp position to prevent particles from getting stuck outside\n                    p.x = Math.max(p.radius, Math.min(dimensions.width - p.radius, p.x));\n                }\n                if (p.y - p.radius <= 0 || p.y + p.radius >= dimensions.height) {\n                    p.vy = -p.vy;\n                    p.y = Math.max(p.radius, Math.min(dimensions.height - p.radius, p.y));\n                }\n                // Mouse interaction\n                if (mouseRef.current.active) {\n                    const dx = mouseRef.current.x - p.x;\n                    const dy = mouseRef.current.y - p.y;\n                    const distSquared = dx * dx + dy * dy;\n                    const maxDistance = 150;\n                    const maxDistanceSquared = maxDistance * maxDistance;\n                    if (distSquared < maxDistanceSquared) {\n                        // Distance-based force calculation (using squared distance for performance)\n                        const force = 0.2 * (1 - Math.sqrt(distSquared) / maxDistance);\n                        const angle = Math.atan2(dy, dx);\n                        // Apply force based on particle type\n                        if (p.isNeuron) {\n                            // Slight attraction for neurons\n                            const attractionForce = 0.05;\n                            p.vx += Math.cos(angle) * attractionForce * deltaTime;\n                            p.vy += Math.sin(angle) * attractionForce * deltaTime;\n                        } else {\n                            // Push regular particles away\n                            p.vx -= Math.cos(angle) * force * deltaTime;\n                            p.vy -= Math.sin(angle) * force * deltaTime;\n                        }\n                    }\n                }\n                // Limit velocity for stability\n                const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy);\n                const maxSpeed = p.isNeuron ? 0.5 : 1;\n                if (speed > maxSpeed) {\n                    p.vx = p.vx / speed * maxSpeed;\n                    p.vy = p.vy / speed * maxSpeed;\n                }\n                // Calculate pulse effect for neurons\n                let displayRadius = p.radius;\n                let currentOpacity = p.opacity;\n                if (p.isNeuron && pulseNodes) {\n                    const pulse = Math.sin(timestamp * p.pulseRate + p.pulsePhase);\n                    displayRadius = p.radius * (1 + 0.2 * pulse);\n                    currentOpacity = p.opacity * (0.8 + 0.2 * pulse);\n                }\n                // Draw connections before particles\n                for (const j of p.connections){\n                    const p2 = particles[j];\n                    const dx = p2.x - p.x;\n                    const dy = p2.y - p.y;\n                    const distance = Math.sqrt(dx * dx + dy * dy);\n                    // Calculate opacity based on distance\n                    const maxDistance = p.isNeuron || p2.isNeuron ? connectDistance * 1.5 : connectDistance;\n                    let lineOpacity = 0.2 * (1 - distance / maxDistance);\n                    // Stronger connections between neurons\n                    if (p.isNeuron && p2.isNeuron) {\n                        lineOpacity *= 1.5;\n                    }\n                    // Create gradient for line\n                    const gradient = ctx.createLinearGradient(p.x, p.y, p2.x, p2.y);\n                    gradient.addColorStop(0, \"\".concat(p.color.replace(\")\", \", \".concat(lineOpacity, \")\"))));\n                    gradient.addColorStop(1, \"\".concat(p2.color.replace(\")\", \", \".concat(lineOpacity, \")\"))));\n                    // Draw line\n                    ctx.beginPath();\n                    ctx.strokeStyle = gradient;\n                    ctx.lineWidth = p.isNeuron && p2.isNeuron ? 0.5 : 0.3;\n                    ctx.moveTo(p.x, p.y);\n                    ctx.lineTo(p2.x, p2.y);\n                    ctx.stroke();\n                }\n                // Draw glow for neurons\n                if (p.isNeuron && enableGlow) {\n                    const glowSize = displayRadius * 8;\n                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowSize);\n                    gradient.addColorStop(0, p.color.replace(\")\", \", \".concat(currentOpacity * 0.4, \")\")));\n                    gradient.addColorStop(1, p.color.replace(\")\", \", 0)\"));\n                    ctx.beginPath();\n                    ctx.fillStyle = gradient;\n                    ctx.arc(p.x, p.y, glowSize, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                // Draw particle\n                ctx.beginPath();\n                ctx.fillStyle = p.color.replace(\")\", \", \".concat(currentOpacity, \")\"));\n                ctx.arc(p.x, p.y, displayRadius, 0, Math.PI * 2);\n                ctx.fill();\n            }\n            frameCount++;\n            mainAnimationRef.current = requestAnimationFrame(animate);\n        };\n        animate(0);\n        // Cleanup\n        return ()=>{\n            if (mainAnimationRef.current) {\n                cancelAnimationFrame(mainAnimationRef.current);\n                mainAnimationRef.current = null;\n            }\n        };\n    }, [\n        isInitialized,\n        dimensions,\n        connectDistance,\n        pulseNodes,\n        enableGlow,\n        dataTransferEffect,\n        createDataPacket\n    ]);\n    // Matrix code rain animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized || !matrixEffect || !matrixCanvasRef.current || dimensions.width <= 0) return;\n        const canvas = matrixCanvasRef.current;\n        const ctx = canvas.getContext(\"2d\", {\n            alpha: true\n        });\n        if (!ctx) return;\n        const animate = ()=>{\n            // Apply a semi-transparent clear for trailing effect\n            ctx.fillStyle = \"rgba(0, 0, 0, 0.05)\";\n            ctx.fillRect(0, 0, dimensions.width, dimensions.height);\n            // Update fragments\n            const fragments = codeFragmentsRef.current;\n            const updatedFragments = [];\n            for(let i = 0; i < fragments.length; i++){\n                const fragment = fragments[i];\n                // Update age\n                const updatedAge = fragment.age + 1;\n                // Check if expired\n                if (updatedAge > fragment.lifespan) {\n                    continue;\n                }\n                // Update position based on flow direction\n                let updatedY = fragment.y;\n                if (flowDirection === \"up\") {\n                    updatedY -= fragment.speed;\n                } else if (flowDirection === \"down\") {\n                    updatedY += fragment.speed;\n                } else {\n                    updatedY += (Math.random() > 0.5 ? 1 : -1) * fragment.speed;\n                }\n                // Skip if out of bounds\n                if (updatedY < -20 || updatedY > dimensions.height + 20) {\n                    continue;\n                }\n                // Calculate opacity based on lifecycle\n                const lifecycleRatio = updatedAge / fragment.lifespan;\n                let opacity = fragment.opacity;\n                if (lifecycleRatio < 0.2) {\n                    // Fade in\n                    opacity *= lifecycleRatio * 5;\n                } else if (lifecycleRatio > 0.8) {\n                    // Fade out\n                    opacity *= 1 - (lifecycleRatio - 0.8) * 5;\n                }\n                // Draw character\n                ctx.font = '14px \"JetBrains Mono\", monospace';\n                // Color based on theme or multi-color\n                if (colorScheme === \"multi\") {\n                    ctx.fillStyle = \"hsl(\".concat(fragment.x * 360 / dimensions.width % 360, \", 100%, 50%, \").concat(opacity, \")\");\n                } else {\n                    ctx.fillStyle = \"\".concat(themeColors[colorScheme].primary).concat(Math.floor(opacity * 255).toString(16).padStart(2, \"0\"));\n                }\n                ctx.fillText(fragment.char, fragment.x, updatedY);\n                // Randomly change character\n                const newChar = Math.random() < 0.05 ? matrixChars[Math.floor(Math.random() * matrixChars.length)] : fragment.char;\n                // Save updated fragment\n                updatedFragments.push({\n                    ...fragment,\n                    y: updatedY,\n                    age: updatedAge,\n                    char: newChar\n                });\n            }\n            // Maintain fragment count\n            const targetCount = Math.min(Math.floor(codeFragmentDensity * (dimensions.width / 1920)), 100);\n            while(updatedFragments.length < targetCount){\n                updatedFragments.push(createCodeFragment(dimensions.width));\n            }\n            codeFragmentsRef.current = updatedFragments;\n            matrixAnimationRef.current = requestAnimationFrame(animate);\n        };\n        animate();\n        return ()=>{\n            if (matrixAnimationRef.current) {\n                cancelAnimationFrame(matrixAnimationRef.current);\n                matrixAnimationRef.current = null;\n            }\n        };\n    }, [\n        isInitialized,\n        matrixEffect,\n        dimensions,\n        colorScheme,\n        codeFragmentDensity,\n        flowDirection,\n        createCodeFragment,\n        themeColors,\n        matrixChars\n    ]);\n    // Data packets animation\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isInitialized || !dataTransferEffect || !dataCanvasRef.current || dimensions.width <= 0) return;\n        const canvas = dataCanvasRef.current;\n        const ctx = canvas.getContext(\"2d\", {\n            alpha: true\n        });\n        if (!ctx) return;\n        const animate = ()=>{\n            ctx.clearRect(0, 0, dimensions.width, dimensions.height);\n            // Update data packets\n            const packets = dataPacketsRef.current;\n            const updatedPackets = [];\n            for(let i = 0; i < packets.length; i++){\n                const packet = packets[i];\n                // Get source and target particles\n                const source = particlesRef.current[packet.sourceIndex];\n                const target = particlesRef.current[packet.targetIndex];\n                if (!source || !target) continue;\n                // Update progress\n                const updatedProgress = packet.progress + packet.speed;\n                // Remove if complete\n                if (updatedProgress >= 1) {\n                    // Reset data transfer state for source\n                    if (source.dataTransfer) {\n                        source.dataTransfer.active = false;\n                    }\n                    continue;\n                }\n                // Calculate position using cubic bezier curve for arc effect\n                const t = updatedProgress;\n                const x1 = source.x;\n                const y1 = source.y;\n                const x2 = target.x;\n                const y2 = target.y;\n                // Control point offset\n                const cpOffsetX = (x2 - x1) * 0.5 - (y2 - y1) * 0.5;\n                const cpOffsetY = (y2 - y1) * 0.5 + (x2 - x1) * 0.5;\n                // Control points\n                const cpX = (x1 + x2) / 2 + cpOffsetX * 0.3;\n                const cpY = (y1 + y2) / 2 + cpOffsetY * 0.3;\n                // Quadratic bezier formula\n                const x = (1 - t) * (1 - t) * x1 + 2 * (1 - t) * t * cpX + t * t * x2;\n                const y = (1 - t) * (1 - t) * y1 + 2 * (1 - t) * t * cpY + t * t * y2;\n                // Draw packet with glow effect\n                if (enableGlow) {\n                    const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, packet.size * 5);\n                    glowGradient.addColorStop(0, \"\".concat(packet.color, \"80\"));\n                    glowGradient.addColorStop(1, \"\".concat(packet.color, \"00\"));\n                    ctx.beginPath();\n                    ctx.fillStyle = glowGradient;\n                    ctx.arc(x, y, packet.size * 5, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                // Draw packet core\n                ctx.beginPath();\n                ctx.fillStyle = packet.color;\n                ctx.arc(x, y, packet.size, 0, Math.PI * 2);\n                ctx.fill();\n                // Add motion blur trail\n                const trailLength = 3;\n                for(let j = 1; j <= trailLength; j++){\n                    const trailT = Math.max(0, t - j * 0.03);\n                    const trailX = (1 - trailT) * (1 - trailT) * x1 + 2 * (1 - trailT) * trailT * cpX + trailT * trailT * x2;\n                    const trailY = (1 - trailT) * (1 - trailT) * y1 + 2 * (1 - trailT) * trailT * cpY + trailT * trailT * y2;\n                    ctx.beginPath();\n                    ctx.fillStyle = \"\".concat(packet.color).concat(Math.floor((0.7 - j * 0.2) * 255).toString(16).padStart(2, \"0\"));\n                    ctx.arc(trailX, trailY, packet.size * (1 - j * 0.2), 0, Math.PI * 2);\n                    ctx.fill();\n                }\n                // Save updated packet\n                updatedPackets.push({\n                    ...packet,\n                    progress: updatedProgress\n                });\n            }\n            dataPacketsRef.current = updatedPackets;\n            dataAnimationRef.current = requestAnimationFrame(animate);\n        };\n        animate();\n        return ()=>{\n            if (dataAnimationRef.current) {\n                cancelAnimationFrame(dataAnimationRef.current);\n                dataAnimationRef.current = null;\n            }\n        };\n    }, [\n        isInitialized,\n        dataTransferEffect,\n        dimensions,\n        enableGlow\n    ]);\n    // Cleanup all animations on unmount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        return ()=>{\n            [\n                mainAnimationRef,\n                matrixAnimationRef,\n                dataAnimationRef\n            ].forEach((ref)=>{\n                if (ref.current) {\n                    cancelAnimationFrame(ref.current);\n                    ref.current = null;\n                }\n            });\n        };\n    }, []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        className: \"\".concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().container), \" \").concat(isLoaded ? (_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().active) : \"\", \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default())[colorScheme]),\n        \"aria-hidden\": \"true\" // Hidden from screen readers as this is decorative\n        ,\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                className: (_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().canvas),\n                width: dimensions.width,\n                height: dimensions.height\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n                lineNumber: 899,\n                columnNumber: 7\n            }, undefined),\n            matrixEffect && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: matrixCanvasRef,\n                className: \"\".concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().canvas), \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().matrixCanvas)),\n                width: dimensions.width,\n                height: dimensions.height\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n                lineNumber: 908,\n                columnNumber: 9\n            }, undefined),\n            dataTransferEffect && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: dataCanvasRef,\n                className: \"\".concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().canvas), \" \").concat((_NeuralParticleSystem_module_css__WEBPACK_IMPORTED_MODULE_2___default().dataCanvas)),\n                width: dimensions.width,\n                height: dimensions.height\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n                lineNumber: 918,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\ck\\\\LandingProspera\\\\prospera-nextjs\\\\src\\\\components\\\\NeuralParticleSystem\\\\NeuralParticleSystem.tsx\",\n        lineNumber: 893,\n        columnNumber: 5\n    }, undefined);\n};\n_s(NeuralParticleSystem, \"rKnUNW9B+S/Hz8xMMt/t2uzntf8=\");\n_c = NeuralParticleSystem;\n/* harmony default export */ __webpack_exports__[\"default\"] = (NeuralParticleSystem);\nvar _c;\n$RefreshReg$(_c, \"NeuralParticleSystem\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL05ldXJhbFBhcnRpY2xlU3lzdGVtLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrREFBK0Q7OztBQUdrQjtBQUMxQjtBQXlEdkQsTUFBTU8sdUJBQTREO1FBQUMsRUFDakVDLFVBQVUsRUFBRSxFQUNaQyxjQUFjLElBQUksRUFDbEJDLGVBQWUsSUFBSSxFQUNuQkMsa0JBQWtCLEdBQUcsRUFDckJDLGNBQWMsT0FBTyxFQUNyQkMsZUFBZSxJQUFJLEVBQ25CQyxxQkFBcUIsSUFBSSxFQUN6QkMsc0JBQXNCLEVBQUUsRUFDeEJDLGdCQUFnQixNQUFNLEVBQ3RCQyxhQUFhLElBQUksRUFDakJDLGFBQWEsSUFBSSxFQUNsQjs7SUFDQyw0QkFBNEI7SUFDNUIsTUFBTUMsWUFBWWhCLDZDQUFNQSxDQUFvQjtJQUM1QyxNQUFNaUIsa0JBQWtCakIsNkNBQU1BLENBQW9CO0lBQ2xELE1BQU1rQixnQkFBZ0JsQiw2Q0FBTUEsQ0FBb0I7SUFDaEQsTUFBTW1CLGVBQWVuQiw2Q0FBTUEsQ0FBaUI7SUFFNUMsdUJBQXVCO0lBQ3ZCLE1BQU0sQ0FBQ29CLFlBQVlDLGNBQWMsR0FBR3ZCLCtDQUFRQSxDQUFDO1FBQUV3QixPQUFPO1FBQUdDLFFBQVE7SUFBRTtJQUNuRSxNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBRzNCLCtDQUFRQSxDQUFDO0lBQ3pDLE1BQU0sQ0FBQzRCLGVBQWVDLGlCQUFpQixHQUFHN0IsK0NBQVFBLENBQUM7SUFFbkQsa0VBQWtFO0lBQ2xFLE1BQU04QixlQUFlNUIsNkNBQU1BLENBQW1CLEVBQUU7SUFDaEQsTUFBTTZCLGlCQUFpQjdCLDZDQUFNQSxDQUFlLEVBQUU7SUFDOUMsTUFBTThCLG1CQUFtQjlCLDZDQUFNQSxDQUFpQixFQUFFO0lBQ2xELE1BQU0rQixXQUFXL0IsNkNBQU1BLENBQUM7UUFBRWdDLEdBQUc7UUFBR0MsR0FBRztRQUFHQyxR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bFBhcnRpY2xlU3lzdGVtL05ldXJhbFBhcnRpY2xlU3lzdGVtLnRzeD81YmU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL05ldXJhbFBhcnRpY2xlU3lzdGVtLnRzeFxyXG4ndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL05ldXJhbFBhcnRpY2xlU3lzdGVtLm1vZHVsZS5jc3MnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOZXVyYWxQYXJ0aWNsZSB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICB2eDogbnVtYmVyO1xyXG4gIHZ5OiBudW1iZXI7XHJcbiAgcmFkaXVzOiBudW1iZXI7XHJcbiAgY29sb3I6IHN0cmluZztcclxuICBvcGFjaXR5OiBudW1iZXI7XHJcbiAgaXNOZXVyb246IGJvb2xlYW47XHJcbiAgcHVsc2VSYXRlOiBudW1iZXI7XHJcbiAgcHVsc2VQaGFzZTogbnVtYmVyO1xyXG4gIGNvbm5lY3Rpb25zOiBudW1iZXJbXTtcclxuICBkYXRhVHJhbnNmZXI/OiB7XHJcbiAgICBhY3RpdmU6IGJvb2xlYW47XHJcbiAgICBwcm9ncmVzczogbnVtYmVyO1xyXG4gICAgc3BlZWQ6IG51bWJlcjtcclxuICAgIHRhcmdldE5vZGVJbmRleDogbnVtYmVyO1xyXG4gIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRGF0YVBhY2tldCB7XHJcbiAgc291cmNlSW5kZXg6IG51bWJlcjtcclxuICB0YXJnZXRJbmRleDogbnVtYmVyO1xyXG4gIHg6IG51bWJlcjtcclxuICB5OiBudW1iZXI7XHJcbiAgcHJvZ3Jlc3M6IG51bWJlcjtcclxuICBzcGVlZDogbnVtYmVyO1xyXG4gIGNvbG9yOiBzdHJpbmc7XHJcbiAgc2l6ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvZGVGcmFnbWVudCB7XHJcbiAgeDogbnVtYmVyO1xyXG4gIHk6IG51bWJlcjtcclxuICBzcGVlZDogbnVtYmVyO1xyXG4gIGNoYXI6IHN0cmluZztcclxuICBvcGFjaXR5OiBudW1iZXI7XHJcbiAgbGlmZXNwYW46IG51bWJlcjtcclxuICBhZ2U6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBOZXVyYWxQYXJ0aWNsZVN5c3RlbVByb3BzIHtcclxuICBkZW5zaXR5PzogbnVtYmVyO1xyXG4gIGludGVyYWN0aXZlPzogYm9vbGVhbjtcclxuICByZWFjdFRvQ2xpY2s/OiBib29sZWFuO1xyXG4gIGNvbm5lY3REaXN0YW5jZT86IG51bWJlcjtcclxuICBjb2xvclNjaGVtZT86ICdncmVlbicgfCAnYmx1ZScgfCAncHVycGxlJyB8ICdtdWx0aScgfCAncmVkJyB8ICdjeWFuJztcclxuICBtYXRyaXhFZmZlY3Q/OiBib29sZWFuO1xyXG4gIGRhdGFUcmFuc2ZlckVmZmVjdD86IGJvb2xlYW47XHJcbiAgY29kZUZyYWdtZW50RGVuc2l0eT86IG51bWJlcjtcclxuICBmbG93RGlyZWN0aW9uPzogJ2Rvd24nIHwgJ3VwJyB8ICdyYW5kb20nO1xyXG4gIHB1bHNlTm9kZXM/OiBib29sZWFuO1xyXG4gIGVuYWJsZUdsb3c/OiBib29sZWFuO1xyXG59XHJcblxyXG5jb25zdCBOZXVyYWxQYXJ0aWNsZVN5c3RlbTogUmVhY3QuRkM8TmV1cmFsUGFydGljbGVTeXN0ZW1Qcm9wcz4gPSAoe1xyXG4gIGRlbnNpdHkgPSA2MCxcclxuICBpbnRlcmFjdGl2ZSA9IHRydWUsXHJcbiAgcmVhY3RUb0NsaWNrID0gdHJ1ZSxcclxuICBjb25uZWN0RGlzdGFuY2UgPSAxNTAsXHJcbiAgY29sb3JTY2hlbWUgPSAnZ3JlZW4nLFxyXG4gIG1hdHJpeEVmZmVjdCA9IHRydWUsXHJcbiAgZGF0YVRyYW5zZmVyRWZmZWN0ID0gdHJ1ZSxcclxuICBjb2RlRnJhZ21lbnREZW5zaXR5ID0gMzAsXHJcbiAgZmxvd0RpcmVjdGlvbiA9ICdkb3duJyxcclxuICBwdWxzZU5vZGVzID0gdHJ1ZSxcclxuICBlbmFibGVHbG93ID0gdHJ1ZVxyXG59KSA9PiB7XHJcbiAgLy8gQ2FudmFzIGFuZCBjb250YWluZXIgcmVmc1xyXG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZjxIVE1MQ2FudmFzRWxlbWVudD4obnVsbCk7XHJcbiAgY29uc3QgbWF0cml4Q2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBkYXRhQ2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcclxuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIFxyXG4gIC8vIFN0YXRlIGZvciBkaW1lbnNpb25zXHJcbiAgY29uc3QgW2RpbWVuc2lvbnMsIHNldERpbWVuc2lvbnNdID0gdXNlU3RhdGUoeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xyXG4gIGNvbnN0IFtpc0xvYWRlZCwgc2V0SXNMb2FkZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBcclxuICAvLyBSZWZzIGZvciBhbmltYXRpb25zIGFuZCBkYXRhIC0gdXNpbmcgdXNlUmVmIHRvIGF2b2lkIHJlLXJlbmRlcnNcclxuICBjb25zdCBwYXJ0aWNsZXNSZWYgPSB1c2VSZWY8TmV1cmFsUGFydGljbGVbXT4oW10pO1xyXG4gIGNvbnN0IGRhdGFQYWNrZXRzUmVmID0gdXNlUmVmPERhdGFQYWNrZXRbXT4oW10pO1xyXG4gIGNvbnN0IGNvZGVGcmFnbWVudHNSZWYgPSB1c2VSZWY8Q29kZUZyYWdtZW50W10+KFtdKTtcclxuICBjb25zdCBtb3VzZVJlZiA9IHVzZVJlZih7IHg6IDAsIHk6IDAsIGFjdGl2ZTogZmFsc2UgfSk7XHJcbiAgY29uc3QgbGFzdENsaWNrUmVmID0gdXNlUmVmKHsgeDogMCwgeTogMCwgdGltZTogMCB9KTtcclxuICBcclxuICAvLyBBbmltYXRpb24gZnJhbWUgcmVmc1xyXG4gIGNvbnN0IG1haW5BbmltYXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgY29uc3QgbWF0cml4QW5pbWF0aW9uUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xyXG4gIGNvbnN0IGRhdGFBbmltYXRpb25SZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XHJcbiAgXHJcbiAgLy8gTWF0cml4IGNoYXJhY3RlcnMgLSBtZW1vIGZvciBwZXJmb3JtYW5jZVxyXG4gIGNvbnN0IG1hdHJpeENoYXJzID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICBjb25zdCBzdGFuZGFyZENoYXJzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODkkKy0qLz08Pltde318fl4lI0AhPzs6LC5cIi5zcGxpdCgnJyk7XHJcbiAgICBjb25zdCBxdWFudHVtQ2hhcnMgPSBcIs6ozqbOqc6xzrLOs860zrXOts63zrjOuc66zrvOvM69zr7PgM+Bz4PPhM+Fz4bPh8+Iz4niiJ7iiKviiILiiIfiiJHiiI/iiJriiJviiJziiJ3iiJ5cIi5zcGxpdCgnJyk7XHJcbiAgICByZXR1cm4gWy4uLnN0YW5kYXJkQ2hhcnMsIC4uLnF1YW50dW1DaGFycy5maWx0ZXIoKF8sIGkpID0+IGkgJSAzID09PSAwKV07XHJcbiAgfSwgW10pO1xyXG4gIFxyXG4gIC8vIFRoZW1lIGNvbG9ycyB3aXRoIGVuaGFuY2VkIGNvbG9yIHNjaGVtZXNcclxuICBjb25zdCB0aGVtZUNvbG9ycyA9IHVzZU1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgdGhlbWVzID0ge1xyXG4gICAgICBncmVlbjoge1xyXG4gICAgICAgIHByaW1hcnk6ICcjMDBmZjAwJyxcclxuICAgICAgICBzZWNvbmRhcnk6ICcjMDBjYzQ0JyxcclxuICAgICAgICB0ZXJ0aWFyeTogJyMwMDMzMDAnLFxyXG4gICAgICAgIGFjY2VudDogJyMzM2ZmMzMnLFxyXG4gICAgICAgIGJhY2tncm91bmQ6ICcjMDAxMTAwJyxcclxuICAgICAgICBkYXRhOiAnI2NjZmZjYydcclxuICAgICAgfSxcclxuICAgICAgYmx1ZToge1xyXG4gICAgICAgIHByaW1hcnk6ICcjMDA4OGZmJyxcclxuICAgICAgICBzZWNvbmRhcnk6ICcjMDBjY2ZmJyxcclxuICAgICAgICB0ZXJ0aWFyeTogJyMwMDAwNjYnLFxyXG4gICAgICAgIGFjY2VudDogJyMzM2NjZmYnLFxyXG4gICAgICAgIGJhY2tncm91bmQ6ICcjMDAwMDMzJyxcclxuICAgICAgICBkYXRhOiAnI2NjZjVmZidcclxuICAgICAgfSxcclxuICAgICAgcHVycGxlOiB7XHJcbiAgICAgICAgcHJpbWFyeTogJyNhYTAwZmYnLFxyXG4gICAgICAgIHNlY29uZGFyeTogJyNjYzY2ZmYnLFxyXG4gICAgICAgIHRlcnRpYXJ5OiAnIzMzMDA2NicsXHJcbiAgICAgICAgYWNjZW50OiAnI2RkOTlmZicsXHJcbiAgICAgICAgYmFja2dyb3VuZDogJyMxMTAwMjInLFxyXG4gICAgICAgIGRhdGE6ICcjZWVjY2ZmJ1xyXG4gICAgICB9LFxyXG4gICAgICByZWQ6IHtcclxuICAgICAgICBwcmltYXJ5OiAnI2ZmMzMxMScsXHJcbiAgICAgICAgc2Vjb25kYXJ5OiAnI2ZmNjY0NCcsXHJcbiAgICAgICAgdGVydGlhcnk6ICcjNjYwMDAwJyxcclxuICAgICAgICBhY2NlbnQ6ICcjZmY5OTc3JyxcclxuICAgICAgICBiYWNrZ3JvdW5kOiAnIzExMDAwMCcsXHJcbiAgICAgICAgZGF0YTogJyNmZmNjY2MnXHJcbiAgICAgIH0sXHJcbiAgICAgIGN5YW46IHtcclxuICAgICAgICBwcmltYXJ5OiAnIzAwZmZmZicsXHJcbiAgICAgICAgc2Vjb25kYXJ5OiAnIzY2ZmZmZicsXHJcbiAgICAgICAgdGVydGlhcnk6ICcjMDA2NjY2JyxcclxuICAgICAgICBhY2NlbnQ6ICcjOTlmZmZmJyxcclxuICAgICAgICBiYWNrZ3JvdW5kOiAnIzAwMTExMScsXHJcbiAgICAgICAgZGF0YTogJyNjY2ZmZmYnXHJcbiAgICAgIH0sXHJcbiAgICAgIG11bHRpOiB7XHJcbiAgICAgICAgcHJpbWFyeTogJyMwMGZmMDAnLFxyXG4gICAgICAgIHNlY29uZGFyeTogJyMwMGNjZmYnLFxyXG4gICAgICAgIHRlcnRpYXJ5OiAnI2FhMDBmZicsXHJcbiAgICAgICAgYWNjZW50OiAnI2ZmMzMxMScsXHJcbiAgICAgICAgYmFja2dyb3VuZDogJyMwMDAwMjInLFxyXG4gICAgICAgIGRhdGE6ICcjZmZmZmZmJ1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gdGhlbWVzO1xyXG4gIH0sIFtdKTtcclxuICBcclxuICAvLyBJbml0aWFsaXplIGRpbWVuc2lvbnMgYW5kIGxpc3RlbmVyc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIWNvbnRhaW5lclJlZi5jdXJyZW50KSByZXR1cm47XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB7IG9mZnNldFdpZHRoLCBvZmZzZXRIZWlnaHQgfSA9IGNvbnRhaW5lclJlZi5jdXJyZW50O1xyXG4gICAgICBcclxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgZGltZW5zaW9ucyBhY3R1YWxseSBjaGFuZ2VkIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzXHJcbiAgICAgIHNldERpbWVuc2lvbnMocHJldkRpbWVuc2lvbnMgPT4ge1xyXG4gICAgICAgIGlmIChwcmV2RGltZW5zaW9ucy53aWR0aCAhPT0gb2Zmc2V0V2lkdGggfHwgcHJldkRpbWVuc2lvbnMuaGVpZ2h0ICE9PSBvZmZzZXRIZWlnaHQpIHtcclxuICAgICAgICAgIHJldHVybiB7IHdpZHRoOiBvZmZzZXRXaWR0aCwgaGVpZ2h0OiBvZmZzZXRIZWlnaHQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByZXZEaW1lbnNpb25zO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIC8vIFNldCBpbml0aWFsIGRpbWVuc2lvbnNcclxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgIFxyXG4gICAgLy8gRGVib3VuY2UgcmVzaXplIGhhbmRsZXIgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxyXG4gICAgbGV0IHJlc2l6ZVRpbWVyOiBOb2RlSlMuVGltZW91dDtcclxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHJlc2l6ZVRpbWVyKTtcclxuICAgICAgcmVzaXplVGltZXIgPSBzZXRUaW1lb3V0KHVwZGF0ZURpbWVuc2lvbnMsIDEwMCk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xyXG4gICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZXIpO1xyXG4gICAgfTtcclxuICB9LCBbXSk7XHJcbiAgXHJcbiAgLy8gR2VuZXJhdGUgcGFydGljbGUgY29sb3IgYmFzZWQgb24gY2hvc2VuIHNjaGVtZSAtIG1lbW9pemVkIGZvciBwZXJmb3JtYW5jZVxyXG4gIGNvbnN0IGdldFBhcnRpY2xlQ29sb3IgPSB1c2VDYWxsYmFjaygoaXNOZXVyb24gPSBmYWxzZSkgPT4ge1xyXG4gICAgY29uc3QgY29sb3JzID0gdGhlbWVDb2xvcnNbY29sb3JTY2hlbWVdO1xyXG4gICAgXHJcbiAgICBpZiAoY29sb3JTY2hlbWUgPT09ICdtdWx0aScpIHtcclxuICAgICAgY29uc3Qgc2NoZW1lcyA9IFsnZ3JlZW4nLCAnYmx1ZScsICdwdXJwbGUnLCAncmVkJywgJ2N5YW4nXTtcclxuICAgICAgY29uc3QgcmFuZG9tU2NoZW1lID0gc2NoZW1lc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBzY2hlbWVzLmxlbmd0aCldO1xyXG4gICAgICBjb25zdCBzY2hlbWVDb2xvcnMgPSB0aGVtZUNvbG9yc1tyYW5kb21TY2hlbWVdO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGlzTmV1cm9uIFxyXG4gICAgICAgID8gc2NoZW1lQ29sb3JzLnByaW1hcnlcclxuICAgICAgICA6IHNjaGVtZUNvbG9ycy5zZWNvbmRhcnk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBpc05ldXJvbiA/IGNvbG9ycy5wcmltYXJ5IDogY29sb3JzLnNlY29uZGFyeTtcclxuICB9LCBbY29sb3JTY2hlbWUsIHRoZW1lQ29sb3JzXSk7XHJcbiAgXHJcbiAgLy8gSW5pdGlhbGl6ZSBwYXJ0aWNsZXMgd2hlbiBkaW1lbnNpb25zIGNoYW5nZVxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8PSAwIHx8IGRpbWVuc2lvbnMuaGVpZ2h0IDw9IDAgfHwgaXNJbml0aWFsaXplZCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICAvLyBTZXQgY2FudmFzIHNpemVzIHdpdGggZGV2aWNlIHBpeGVsIHJhdGlvIGZvciBjcmlzcCByZW5kZXJpbmdcclxuICAgIGNvbnN0IGRwciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSA6IDE7XHJcbiAgICBcclxuICAgIC8vIEluaXRpYWxpemUgY2FudmFzIGNvbnRleHRzXHJcbiAgICBjb25zdCB1cGRhdGVDYW52YXMgPSAoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCB8IG51bGwpID0+IHtcclxuICAgICAgaWYgKCFjYW52YXMpIHJldHVybjtcclxuICAgICAgY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aCAqIGRwcjtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICogZHByO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgIGlmIChjdHgpIHtcclxuICAgICAgICBjdHguc2NhbGUoZHByLCBkcHIpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICB1cGRhdGVDYW52YXMoY2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgdXBkYXRlQ2FudmFzKG1hdHJpeENhbnZhc1JlZi5jdXJyZW50KTtcclxuICAgIHVwZGF0ZUNhbnZhcyhkYXRhQ2FudmFzUmVmLmN1cnJlbnQpO1xyXG4gICAgXHJcbiAgICAvLyBJbml0aWFsaXplIHBhcnRpY2xlcyBhbmQgZWZmZWN0c1xyXG4gICAgaW5pdFBhcnRpY2xlcygpO1xyXG4gICAgXHJcbiAgICBpZiAobWF0cml4RWZmZWN0KSB7XHJcbiAgICAgIGluaXRDb2RlRnJhZ21lbnRzKCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIE1hcmsgYXMgaW5pdGlhbGl6ZWRcclxuICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSk7XHJcbiAgICBcclxuICAgIC8vIFNldCBsb2FkZWQgd2l0aCBkZWxheSBmb3IgdHJhbnNpdGlvblxyXG4gICAgY29uc3QgbG9hZFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHNldElzTG9hZGVkKHRydWUpO1xyXG4gICAgfSwgMzAwKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChsb2FkVGltZXIpO1xyXG4gIH0sIFtkaW1lbnNpb25zLCBtYXRyaXhFZmZlY3QsIGlzSW5pdGlhbGl6ZWRdKTtcclxuICBcclxuICAvLyBJbml0aWFsaXplIHBhcnRpY2xlc1xyXG4gIGNvbnN0IGluaXRQYXJ0aWNsZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGRpbWVuc2lvbnM7XHJcbiAgICBcclxuICAgIC8vIFNjYWxlIGRlbnNpdHkgYmFzZWQgb24gc2NyZWVuIHNpemUgdG8gbWFpbnRhaW4gY29uc2lzdGVudCBhcHBlYXJhbmNlXHJcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9ICh3aWR0aCAqIGhlaWdodCkgLyAoMTkyMCAqIDEwODApO1xyXG4gICAgY29uc3Qgc2NhbGVkRGVuc2l0eSA9IE1hdGgubWF4KE1hdGguZmxvb3IoZGVuc2l0eSAqIHNjYWxlRmFjdG9yKSwgMjApO1xyXG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihzY2FsZWREZW5zaXR5LCA1MDApOyAvLyBDYXAgYXQgNTAwIHBhcnRpY2xlcyBmb3IgcGVyZm9ybWFuY2VcclxuICAgIFxyXG4gICAgY29uc3QgcGFydGljbGVzOiBOZXVyYWxQYXJ0aWNsZVtdID0gW107XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBpc05ldXJvbiA9IE1hdGgucmFuZG9tKCkgPCAwLjE1OyAvLyAxNSUgY2hhbmNlIHRvIGJlIGEgbmV1cm9uIG5vZGVcclxuICAgICAgXHJcbiAgICAgIHBhcnRpY2xlcy5wdXNoKHtcclxuICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogd2lkdGgsXHJcbiAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGhlaWdodCxcclxuICAgICAgICB2eDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogKGlzTmV1cm9uID8gMC4yIDogMC41KSwgLy8gTmV1cm9ucyBtb3ZlIHNsb3dlclxyXG4gICAgICAgIHZ5OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAoaXNOZXVyb24gPyAwLjIgOiAwLjUpLFxyXG4gICAgICAgIHJhZGl1czogaXNOZXVyb24gPyBNYXRoLnJhbmRvbSgpICogMyArIDIgOiBNYXRoLnJhbmRvbSgpICogMS41ICsgMC41LFxyXG4gICAgICAgIGNvbG9yOiBnZXRQYXJ0aWNsZUNvbG9yKGlzTmV1cm9uKSxcclxuICAgICAgICBvcGFjaXR5OiBpc05ldXJvbiA/IE1hdGgucmFuZG9tKCkgKiAwLjMgKyAwLjcgOiBNYXRoLnJhbmRvbSgpICogMC40ICsgMC4yLFxyXG4gICAgICAgIGlzTmV1cm9uLFxyXG4gICAgICAgIHB1bHNlUmF0ZTogTWF0aC5yYW5kb20oKSAqIDAuMDIgKyAwLjAxLFxyXG4gICAgICAgIHB1bHNlUGhhc2U6IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMixcclxuICAgICAgICBjb25uZWN0aW9uczogW10sXHJcbiAgICAgICAgZGF0YVRyYW5zZmVyOiBpc05ldXJvbiA/IHtcclxuICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICBwcm9ncmVzczogMCxcclxuICAgICAgICAgIHNwZWVkOiAwLFxyXG4gICAgICAgICAgdGFyZ2V0Tm9kZUluZGV4OiAtMVxyXG4gICAgICAgIH0gOiB1bmRlZmluZWRcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50ID0gcGFydGljbGVzO1xyXG4gIH0sIFtkaW1lbnNpb25zLCBkZW5zaXR5LCBnZXRQYXJ0aWNsZUNvbG9yXSk7XHJcbiAgXHJcbiAgLy8gSW5pdGlhbGl6ZSBjb2RlIGZyYWdtZW50cyBmb3IgbWF0cml4IGVmZmVjdFxyXG4gIGNvbnN0IGluaXRDb2RlRnJhZ21lbnRzID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBkaW1lbnNpb25zO1xyXG4gICAgXHJcbiAgICAvLyBTY2FsZSBmcmFnbWVudHMgYmFzZWQgb24gc2NyZWVuIHdpZHRoXHJcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKE1hdGguZmxvb3IoY29kZUZyYWdtZW50RGVuc2l0eSAqIHdpZHRoIC8gMTkyMCksIDEyMCk7XHJcbiAgICBjb25zdCBmcmFnbWVudHM6IENvZGVGcmFnbWVudFtdID0gW107XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBmcmFnbWVudHMucHVzaChjcmVhdGVDb2RlRnJhZ21lbnQod2lkdGgpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29kZUZyYWdtZW50c1JlZi5jdXJyZW50ID0gZnJhZ21lbnRzO1xyXG4gIH0sIFtkaW1lbnNpb25zLCBjb2RlRnJhZ21lbnREZW5zaXR5XSk7XHJcbiAgXHJcbiAgLy8gQ3JlYXRlIGEgbmV3IGNvZGUgZnJhZ21lbnRcclxuICBjb25zdCBjcmVhdGVDb2RlRnJhZ21lbnQgPSB1c2VDYWxsYmFjaygod2lkdGg6IG51bWJlcikgPT4ge1xyXG4gICAgLy8gU3RhcnQgcG9zaXRpb24gYmFzZWQgb24gZmxvdyBkaXJlY3Rpb25cclxuICAgIGNvbnN0IHN0YXJ0WSA9IGZsb3dEaXJlY3Rpb24gPT09ICd1cCcgXHJcbiAgICAgID8gZGltZW5zaW9ucy5oZWlnaHQgKyBNYXRoLnJhbmRvbSgpICogNTAgXHJcbiAgICAgIDogLU1hdGgucmFuZG9tKCkgKiA1MDtcclxuICAgIFxyXG4gICAgY29uc3QgZnJhZ21lbnQ6IENvZGVGcmFnbWVudCA9IHtcclxuICAgICAgeDogTWF0aC5yYW5kb20oKSAqIHdpZHRoLFxyXG4gICAgICB5OiBzdGFydFksXHJcbiAgICAgIHNwZWVkOiBNYXRoLnJhbmRvbSgpICogMiArIDEsXHJcbiAgICAgIGNoYXI6IG1hdHJpeENoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1hdHJpeENoYXJzLmxlbmd0aCldLFxyXG4gICAgICBvcGFjaXR5OiBNYXRoLnJhbmRvbSgpICogMC41ICsgMC4zLFxyXG4gICAgICBsaWZlc3BhbjogTWF0aC5yYW5kb20oKSAqIDIwMCArIDEwMCxcclxuICAgICAgYWdlOiAwXHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICByZXR1cm4gZnJhZ21lbnQ7XHJcbiAgfSwgW2RpbWVuc2lvbnMuaGVpZ2h0LCBmbG93RGlyZWN0aW9uLCBtYXRyaXhDaGFyc10pO1xyXG4gIFxyXG4gIC8vIENyZWF0ZSBhIG5ldyBkYXRhIHBhY2tldCBmb3IgdHJhbnNmZXIgYmV0d2VlbiBub2Rlc1xyXG4gIGNvbnN0IGNyZWF0ZURhdGFQYWNrZXQgPSB1c2VDYWxsYmFjaygoc291cmNlSW5kZXg6IG51bWJlciwgdGFyZ2V0SW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgY29uc3Qgc291cmNlID0gcGFydGljbGVzUmVmLmN1cnJlbnRbc291cmNlSW5kZXhdO1xyXG4gICAgY29uc3QgdGFyZ2V0ID0gcGFydGljbGVzUmVmLmN1cnJlbnRbdGFyZ2V0SW5kZXhdO1xyXG4gICAgXHJcbiAgICBpZiAoIXNvdXJjZSB8fCAhdGFyZ2V0KSByZXR1cm4gbnVsbDtcclxuICAgIFxyXG4gICAgY29uc3QgY29sb3JzID0gdGhlbWVDb2xvcnNbY29sb3JTY2hlbWVdO1xyXG4gICAgXHJcbiAgICBjb25zdCBwYWNrZXQ6IERhdGFQYWNrZXQgPSB7XHJcbiAgICAgIHNvdXJjZUluZGV4LFxyXG4gICAgICB0YXJnZXRJbmRleCxcclxuICAgICAgeDogc291cmNlLngsXHJcbiAgICAgIHk6IHNvdXJjZS55LFxyXG4gICAgICBwcm9ncmVzczogMCxcclxuICAgICAgc3BlZWQ6IE1hdGgucmFuZG9tKCkgKiAwLjAyICsgMC4wMSxcclxuICAgICAgY29sb3I6IGNvbG9ycy5kYXRhLFxyXG4gICAgICBzaXplOiBNYXRoLnJhbmRvbSgpICogMS41ICsgMVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHBhY2tldDtcclxuICB9LCBbY29sb3JTY2hlbWUsIHRoZW1lQ29sb3JzXSk7XHJcbiAgXHJcbiAgLy8gSGFuZGxlIG1vdXNlIG1vdmVtZW50XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghaW50ZXJhY3RpdmUgfHwgIWNhbnZhc1JlZi5jdXJyZW50IHx8ICFpc0luaXRpYWxpemVkKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IChlOiBNb3VzZUV2ZW50KSA9PiB7XHJcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXNSZWYuY3VycmVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgIGlmICghcmVjdCkgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgbW91c2VSZWYuY3VycmVudCA9IHtcclxuICAgICAgICB4OiBlLmNsaWVudFggLSByZWN0LmxlZnQsXHJcbiAgICAgICAgeTogZS5jbGllbnRZIC0gcmVjdC50b3AsXHJcbiAgICAgICAgYWN0aXZlOiB0cnVlXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBjb25zdCBoYW5kbGVNb3VzZUxlYXZlID0gKCkgPT4ge1xyXG4gICAgICBtb3VzZVJlZi5jdXJyZW50LmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSAoZTogTW91c2VFdmVudCkgPT4ge1xyXG4gICAgICBpZiAoIXJlYWN0VG9DbGljayB8fCAhY2FudmFzUmVmLmN1cnJlbnQpIHJldHVybjtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXNSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdDtcclxuICAgICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wO1xyXG4gICAgICBcclxuICAgICAgLy8gTGltaXQgY2xpY2sgaGFuZGxpbmcgcmF0ZSBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIGlmIChub3cgLSBsYXN0Q2xpY2tSZWYuY3VycmVudC50aW1lIDwgMzAwKSByZXR1cm47IC8vIERlYm91bmNlIGNsaWNrc1xyXG4gICAgICBcclxuICAgICAgLy8gU3RvcmUgY2xpY2sgcG9zaXRpb24gYW5kIHRpbWVcclxuICAgICAgbGFzdENsaWNrUmVmLmN1cnJlbnQgPSB7XHJcbiAgICAgICAgeCxcclxuICAgICAgICB5LFxyXG4gICAgICAgIHRpbWU6IG5vd1xyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgLy8gQ3JlYXRlIGFkZGl0aW9uYWwgcGFydGljbGVzXHJcbiAgICAgIGFkZFBhcnRpY2xlc0F0UG9pbnQoeCwgeSwgNSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgY29kZSBmcmFnbWVudHMgYXQgY2xpY2sgcG9pbnRcclxuICAgICAgaWYgKG1hdHJpeEVmZmVjdCkge1xyXG4gICAgICAgIGFkZENvZGVGcmFnbWVudHNBdFBvaW50KHgsIHksIDEwKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhhbmRsZU1vdXNlTGVhdmUpO1xyXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xyXG4gICAgXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoYW5kbGVNb3VzZUxlYXZlKTtcclxuICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xyXG4gICAgfTtcclxuICB9LCBbaW50ZXJhY3RpdmUsIHJlYWN0VG9DbGljaywgbWF0cml4RWZmZWN0LCBpc0luaXRpYWxpemVkXSk7XHJcbiAgXHJcbiAgLy8gQWRkIHBhcnRpY2xlcyBhdCBhIHNwZWNpZmljIHBvaW50XHJcbiAgY29uc3QgYWRkUGFydGljbGVzQXRQb2ludCA9IHVzZUNhbGxiYWNrKCh4OiBudW1iZXIsIHk6IG51bWJlciwgY291bnQ6IG51bWJlcikgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICBjb25zdCBzcGVlZCA9IE1hdGgucmFuZG9tKCkgKiAyICsgMTtcclxuICAgICAgY29uc3QgaXNOZXVyb24gPSBNYXRoLnJhbmRvbSgpIDwgMC4zOyAvLyBIaWdoZXIgY2hhbmNlIHRvIGJlIGEgbmV1cm9uXHJcbiAgICAgIFxyXG4gICAgICAvLyBDYXAgdG90YWwgcGFydGljbGUgY291bnQgdG8gcHJldmVudCBwZXJmb3JtYW5jZSBpc3N1ZXNcclxuICAgICAgaWYgKHBhcnRpY2xlc1JlZi5jdXJyZW50Lmxlbmd0aCA8IDUwMCkge1xyXG4gICAgICAgIHBhcnRpY2xlc1JlZi5jdXJyZW50LnB1c2goe1xyXG4gICAgICAgICAgeCxcclxuICAgICAgICAgIHksXHJcbiAgICAgICAgICB2eDogTWF0aC5jb3MoYW5nbGUpICogc3BlZWQgKiAwLjUsXHJcbiAgICAgICAgICB2eTogTWF0aC5zaW4oYW5nbGUpICogc3BlZWQgKiAwLjUsXHJcbiAgICAgICAgICByYWRpdXM6IGlzTmV1cm9uID8gTWF0aC5yYW5kb20oKSAqIDMgKyAyIDogTWF0aC5yYW5kb20oKSAqIDEuNSArIDAuNSxcclxuICAgICAgICAgIGNvbG9yOiBnZXRQYXJ0aWNsZUNvbG9yKGlzTmV1cm9uKSxcclxuICAgICAgICAgIG9wYWNpdHk6IGlzTmV1cm9uID8gTWF0aC5yYW5kb20oKSAqIDAuMyArIDAuNyA6IE1hdGgucmFuZG9tKCkgKiAwLjQgKyAwLjIsXHJcbiAgICAgICAgICBpc05ldXJvbixcclxuICAgICAgICAgIHB1bHNlUmF0ZTogTWF0aC5yYW5kb20oKSAqIDAuMDIgKyAwLjAxLFxyXG4gICAgICAgICAgcHVsc2VQaGFzZTogTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyLFxyXG4gICAgICAgICAgY29ubmVjdGlvbnM6IFtdLFxyXG4gICAgICAgICAgZGF0YVRyYW5zZmVyOiBpc05ldXJvbiA/IHtcclxuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcclxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDAsXHJcbiAgICAgICAgICAgIHNwZWVkOiAwLFxyXG4gICAgICAgICAgICB0YXJnZXROb2RlSW5kZXg6IC0xXHJcbiAgICAgICAgICB9IDogdW5kZWZpbmVkXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbZ2V0UGFydGljbGVDb2xvcl0pO1xyXG4gIFxyXG4gIC8vIEFkZCBjb2RlIGZyYWdtZW50cyBhdCBhIHNwZWNpZmljIHBvaW50XHJcbiAgY29uc3QgYWRkQ29kZUZyYWdtZW50c0F0UG9pbnQgPSB1c2VDYWxsYmFjaygoeDogbnVtYmVyLCB5OiBudW1iZXIsIGNvdW50OiBudW1iZXIpID0+IHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICBjb25zdCBmcmFnbWVudDogQ29kZUZyYWdtZW50ID0ge1xyXG4gICAgICAgIHg6IHggKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMDAsXHJcbiAgICAgICAgeSxcclxuICAgICAgICBzcGVlZDogTWF0aC5yYW5kb20oKSAqIDMgKyAyLFxyXG4gICAgICAgIGNoYXI6IG1hdHJpeENoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1hdHJpeENoYXJzLmxlbmd0aCldLFxyXG4gICAgICAgIG9wYWNpdHk6IE1hdGgucmFuZG9tKCkgKiAwLjcgKyAwLjUsXHJcbiAgICAgICAgbGlmZXNwYW46IE1hdGgucmFuZG9tKCkgKiAxNTAgKyA1MCxcclxuICAgICAgICBhZ2U6IDBcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGNvZGVGcmFnbWVudHNSZWYuY3VycmVudC5wdXNoKGZyYWdtZW50KTtcclxuICAgIH1cclxuICB9LCBbbWF0cml4Q2hhcnNdKTtcclxuICBcclxuICAvLyBNYWluIGFuaW1hdGlvbiBsb29wIGZvciBwYXJ0aWNsZXMgYW5kIGNvbm5lY3Rpb25zXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQgfHwgIWlzSW5pdGlhbGl6ZWQgfHwgZGltZW5zaW9ucy53aWR0aCA8PSAwKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xyXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBsZXQgZnJhbWVDb3VudCA9IDA7XHJcbiAgICBsZXQgbGFzdFRpbWVzdGFtcCA9IDA7XHJcbiAgICBcclxuICAgIGNvbnN0IGFuaW1hdGUgPSAodGltZXN0YW1wOiBudW1iZXIpID0+IHtcclxuICAgICAgLy8gQ2FsY3VsYXRlIGRlbHRhIHRpbWUgZm9yIHNtb290aCBhbmltYXRpb25zIHJlZ2FyZGxlc3Mgb2YgZnJhbWUgcmF0ZVxyXG4gICAgICBjb25zdCBkZWx0YVRpbWUgPSBsYXN0VGltZXN0YW1wID8gKHRpbWVzdGFtcCAtIGxhc3RUaW1lc3RhbXApIC8gMTYuNjY3IDogMTtcclxuICAgICAgbGFzdFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgICAgXHJcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcclxuICAgICAgXHJcbiAgICAgIC8vIE9ubHkgcmVjb21wdXRlIGNvbm5lY3Rpb25zIGV2ZXJ5IGZldyBmcmFtZXMgZm9yIHBlcmZvcm1hbmNlXHJcbiAgICAgIGNvbnN0IHNob3VsZENvbXB1dGVDb25uZWN0aW9ucyA9IGZyYW1lQ291bnQgJSAzID09PSAwO1xyXG4gICAgICBcclxuICAgICAgaWYgKHNob3VsZENvbXB1dGVDb25uZWN0aW9ucykge1xyXG4gICAgICAgIC8vIFJlc2V0IGNvbm5lY3Rpb25zXHJcbiAgICAgICAgcGFydGljbGVzUmVmLmN1cnJlbnQuZm9yRWFjaChwID0+IHtcclxuICAgICAgICAgIHAuY29ubmVjdGlvbnMgPSBbXTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb21wdXRlIGNvbm5lY3Rpb25zIC0gcXVhZHJhdGljIG9wZXJhdGlvbiwgc28gd2Ugb3B0aW1pemUgaXRcclxuICAgICAgICBjb25zdCBwYXJ0aWNsZXMgPSBwYXJ0aWNsZXNSZWYuY3VycmVudDtcclxuICAgICAgICBjb25zdCBsZW4gPSBwYXJ0aWNsZXMubGVuZ3RoO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHAgPSBwYXJ0aWNsZXNbaV07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IGxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAyID0gcGFydGljbGVzW2pdO1xyXG4gICAgICAgICAgICBjb25zdCBkeCA9IHAyLnggLSBwLng7XHJcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gcDIueSAtIHAueTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIFVzaW5nIHNxdWFyZWQgZGlzdGFuY2UgdG8gYXZvaWQgc3F1YXJlIHJvb3Qgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RTcXVhcmVkID0gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyBTZXQgY29ubmVjdGlvbiBkaXN0YW5jZSBiYXNlZCBvbiB3aGV0aGVyIGl0J3MgYSBuZXVyb25cclxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkRpc3RhbmNlU3F1YXJlZCA9IChwLmlzTmV1cm9uIHx8IHAyLmlzTmV1cm9uKSBcclxuICAgICAgICAgICAgICA/IGNvbm5lY3REaXN0YW5jZSAqIGNvbm5lY3REaXN0YW5jZSAqIDIuMjUgLy8gMS41XjJcclxuICAgICAgICAgICAgICA6IGNvbm5lY3REaXN0YW5jZSAqIGNvbm5lY3REaXN0YW5jZTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChkaXN0U3F1YXJlZCA8IGNvbm5lY3Rpb25EaXN0YW5jZVNxdWFyZWQpIHtcclxuICAgICAgICAgICAgICBwLmNvbm5lY3Rpb25zLnB1c2goaik7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gUmFuZG9tbHkgYWN0aXZhdGUgZGF0YSB0cmFuc2ZlciBiZXR3ZWVuIG5ldXJvbnNcclxuICAgICAgICAgICAgICBpZiAoZGF0YVRyYW5zZmVyRWZmZWN0ICYmIHAuaXNOZXVyb24gJiYgcDIuaXNOZXVyb24gJiYgTWF0aC5yYW5kb20oKSA8IDAuMDAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocC5kYXRhVHJhbnNmZXIgJiYgIXAuZGF0YVRyYW5zZmVyLmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICBwLmRhdGFUcmFuc2Zlci5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICBwLmRhdGFUcmFuc2Zlci5wcm9ncmVzcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgIHAuZGF0YVRyYW5zZmVyLnNwZWVkID0gTWF0aC5yYW5kb20oKSAqIDAuMDIgKyAwLjAxO1xyXG4gICAgICAgICAgICAgICAgICBwLmRhdGFUcmFuc2Zlci50YXJnZXROb2RlSW5kZXggPSBqO1xyXG4gICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRhdGEgcGFja2V0XHJcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IGNyZWF0ZURhdGFQYWNrZXQoaSwgaik7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChwYWNrZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhUGFja2V0c1JlZi5jdXJyZW50LnB1c2gocGFja2V0KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGFuZCBkcmF3IHBhcnRpY2xlc1xyXG4gICAgICBjb25zdCBwYXJ0aWNsZXMgPSBwYXJ0aWNsZXNSZWYuY3VycmVudDtcclxuICAgICAgY29uc3QgbGVuID0gcGFydGljbGVzLmxlbmd0aDtcclxuICAgICAgXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwID0gcGFydGljbGVzW2ldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiB3aXRoIGRlbHRhIHRpbWUgZm9yIGNvbnNpc3RlbnQgbW92ZW1lbnRcclxuICAgICAgICBwLnggKz0gcC52eCAqIGRlbHRhVGltZTtcclxuICAgICAgICBwLnkgKz0gcC52eSAqIGRlbHRhVGltZTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBCb3VuZGFyeSBjaGVja3Mgd2l0aCBib3VuY2VcclxuICAgICAgICBpZiAocC54IC0gcC5yYWRpdXMgPD0gMCB8fCBwLnggKyBwLnJhZGl1cyA+PSBkaW1lbnNpb25zLndpZHRoKSB7XHJcbiAgICAgICAgICBwLnZ4ID0gLXAudng7XHJcbiAgICAgICAgICAvLyBDbGFtcCBwb3NpdGlvbiB0byBwcmV2ZW50IHBhcnRpY2xlcyBmcm9tIGdldHRpbmcgc3R1Y2sgb3V0c2lkZVxyXG4gICAgICAgICAgcC54ID0gTWF0aC5tYXgocC5yYWRpdXMsIE1hdGgubWluKGRpbWVuc2lvbnMud2lkdGggLSBwLnJhZGl1cywgcC54KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLnkgLSBwLnJhZGl1cyA8PSAwIHx8IHAueSArIHAucmFkaXVzID49IGRpbWVuc2lvbnMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICBwLnZ5ID0gLXAudnk7XHJcbiAgICAgICAgICBwLnkgPSBNYXRoLm1heChwLnJhZGl1cywgTWF0aC5taW4oZGltZW5zaW9ucy5oZWlnaHQgLSBwLnJhZGl1cywgcC55KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1vdXNlIGludGVyYWN0aW9uXHJcbiAgICAgICAgaWYgKG1vdXNlUmVmLmN1cnJlbnQuYWN0aXZlKSB7XHJcbiAgICAgICAgICBjb25zdCBkeCA9IG1vdXNlUmVmLmN1cnJlbnQueCAtIHAueDtcclxuICAgICAgICAgIGNvbnN0IGR5ID0gbW91c2VSZWYuY3VycmVudC55IC0gcC55O1xyXG4gICAgICAgICAgY29uc3QgZGlzdFNxdWFyZWQgPSBkeCAqIGR4ICsgZHkgKiBkeTtcclxuICAgICAgICAgIGNvbnN0IG1heERpc3RhbmNlID0gMTUwO1xyXG4gICAgICAgICAgY29uc3QgbWF4RGlzdGFuY2VTcXVhcmVkID0gbWF4RGlzdGFuY2UgKiBtYXhEaXN0YW5jZTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGRpc3RTcXVhcmVkIDwgbWF4RGlzdGFuY2VTcXVhcmVkKSB7XHJcbiAgICAgICAgICAgIC8vIERpc3RhbmNlLWJhc2VkIGZvcmNlIGNhbGN1bGF0aW9uICh1c2luZyBzcXVhcmVkIGRpc3RhbmNlIGZvciBwZXJmb3JtYW5jZSlcclxuICAgICAgICAgICAgY29uc3QgZm9yY2UgPSAwLjIgKiAoMSAtIE1hdGguc3FydChkaXN0U3F1YXJlZCkgLyBtYXhEaXN0YW5jZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gQXBwbHkgZm9yY2UgYmFzZWQgb24gcGFydGljbGUgdHlwZVxyXG4gICAgICAgICAgICBpZiAocC5pc05ldXJvbikge1xyXG4gICAgICAgICAgICAgIC8vIFNsaWdodCBhdHRyYWN0aW9uIGZvciBuZXVyb25zXHJcbiAgICAgICAgICAgICAgY29uc3QgYXR0cmFjdGlvbkZvcmNlID0gMC4wNTtcclxuICAgICAgICAgICAgICBwLnZ4ICs9IE1hdGguY29zKGFuZ2xlKSAqIGF0dHJhY3Rpb25Gb3JjZSAqIGRlbHRhVGltZTtcclxuICAgICAgICAgICAgICBwLnZ5ICs9IE1hdGguc2luKGFuZ2xlKSAqIGF0dHJhY3Rpb25Gb3JjZSAqIGRlbHRhVGltZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBQdXNoIHJlZ3VsYXIgcGFydGljbGVzIGF3YXlcclxuICAgICAgICAgICAgICBwLnZ4IC09IE1hdGguY29zKGFuZ2xlKSAqIGZvcmNlICogZGVsdGFUaW1lO1xyXG4gICAgICAgICAgICAgIHAudnkgLT0gTWF0aC5zaW4oYW5nbGUpICogZm9yY2UgKiBkZWx0YVRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTGltaXQgdmVsb2NpdHkgZm9yIHN0YWJpbGl0eVxyXG4gICAgICAgIGNvbnN0IHNwZWVkID0gTWF0aC5zcXJ0KHAudnggKiBwLnZ4ICsgcC52eSAqIHAudnkpO1xyXG4gICAgICAgIGNvbnN0IG1heFNwZWVkID0gcC5pc05ldXJvbiA/IDAuNSA6IDE7XHJcbiAgICAgICAgaWYgKHNwZWVkID4gbWF4U3BlZWQpIHtcclxuICAgICAgICAgIHAudnggPSAocC52eCAvIHNwZWVkKSAqIG1heFNwZWVkO1xyXG4gICAgICAgICAgcC52eSA9IChwLnZ5IC8gc3BlZWQpICogbWF4U3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBwdWxzZSBlZmZlY3QgZm9yIG5ldXJvbnNcclxuICAgICAgICBsZXQgZGlzcGxheVJhZGl1cyA9IHAucmFkaXVzO1xyXG4gICAgICAgIGxldCBjdXJyZW50T3BhY2l0eSA9IHAub3BhY2l0eTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAocC5pc05ldXJvbiAmJiBwdWxzZU5vZGVzKSB7XHJcbiAgICAgICAgICBjb25zdCBwdWxzZSA9IE1hdGguc2luKHRpbWVzdGFtcCAqIHAucHVsc2VSYXRlICsgcC5wdWxzZVBoYXNlKTtcclxuICAgICAgICAgIGRpc3BsYXlSYWRpdXMgPSBwLnJhZGl1cyAqICgxICsgMC4yICogcHVsc2UpO1xyXG4gICAgICAgICAgY3VycmVudE9wYWNpdHkgPSBwLm9wYWNpdHkgKiAoMC44ICsgMC4yICogcHVsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBEcmF3IGNvbm5lY3Rpb25zIGJlZm9yZSBwYXJ0aWNsZXNcclxuICAgICAgICBmb3IgKGNvbnN0IGogb2YgcC5jb25uZWN0aW9ucykge1xyXG4gICAgICAgICAgY29uc3QgcDIgPSBwYXJ0aWNsZXNbal07XHJcbiAgICAgICAgICBjb25zdCBkeCA9IHAyLnggLSBwLng7XHJcbiAgICAgICAgICBjb25zdCBkeSA9IHAyLnkgLSBwLnk7XHJcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBvcGFjaXR5IGJhc2VkIG9uIGRpc3RhbmNlXHJcbiAgICAgICAgICBjb25zdCBtYXhEaXN0YW5jZSA9IChwLmlzTmV1cm9uIHx8IHAyLmlzTmV1cm9uKSBcclxuICAgICAgICAgICAgPyBjb25uZWN0RGlzdGFuY2UgKiAxLjUgXHJcbiAgICAgICAgICAgIDogY29ubmVjdERpc3RhbmNlO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsZXQgbGluZU9wYWNpdHkgPSAwLjIgKiAoMSAtIGRpc3RhbmNlIC8gbWF4RGlzdGFuY2UpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBTdHJvbmdlciBjb25uZWN0aW9ucyBiZXR3ZWVuIG5ldXJvbnNcclxuICAgICAgICAgIGlmIChwLmlzTmV1cm9uICYmIHAyLmlzTmV1cm9uKSB7XHJcbiAgICAgICAgICAgIGxpbmVPcGFjaXR5ICo9IDEuNTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ3JlYXRlIGdyYWRpZW50IGZvciBsaW5lXHJcbiAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwLngsIHAueSwgcDIueCwgcDIueSk7XHJcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYCR7cC5jb2xvci5yZXBsYWNlKCcpJywgYCwgJHtsaW5lT3BhY2l0eX0pYCl9YCk7XHJcbiAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgYCR7cDIuY29sb3IucmVwbGFjZSgnKScsIGAsICR7bGluZU9wYWNpdHl9KWApfWApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBEcmF3IGxpbmVcclxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGdyYWRpZW50O1xyXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHAuaXNOZXVyb24gJiYgcDIuaXNOZXVyb24gPyAwLjUgOiAwLjM7XHJcbiAgICAgICAgICBjdHgubW92ZVRvKHAueCwgcC55KTtcclxuICAgICAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XHJcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERyYXcgZ2xvdyBmb3IgbmV1cm9uc1xyXG4gICAgICAgIGlmIChwLmlzTmV1cm9uICYmIGVuYWJsZUdsb3cpIHtcclxuICAgICAgICAgIGNvbnN0IGdsb3dTaXplID0gZGlzcGxheVJhZGl1cyAqIDg7XHJcbiAgICAgICAgICBjb25zdCBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcclxuICAgICAgICAgICAgcC54LCBwLnksIDAsXHJcbiAgICAgICAgICAgIHAueCwgcC55LCBnbG93U2l6ZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIHAuY29sb3IucmVwbGFjZSgnKScsIGAsICR7Y3VycmVudE9wYWNpdHkgKiAwLjR9KWApKTtcclxuICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBwLmNvbG9yLnJlcGxhY2UoJyknLCAnLCAwKScpKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xyXG4gICAgICAgICAgY3R4LmFyYyhwLngsIHAueSwgZ2xvd1NpemUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERyYXcgcGFydGljbGVcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHAuY29sb3IucmVwbGFjZSgnKScsIGAsICR7Y3VycmVudE9wYWNpdHl9KWApO1xyXG4gICAgICAgIGN0eC5hcmMocC54LCBwLnksIGRpc3BsYXlSYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBmcmFtZUNvdW50Kys7XHJcbiAgICAgIG1haW5BbmltYXRpb25SZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFuaW1hdGUoMCk7XHJcbiAgICBcclxuICAgIC8vIENsZWFudXBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChtYWluQW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShtYWluQW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIG1haW5BbmltYXRpb25SZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW2lzSW5pdGlhbGl6ZWQsIGRpbWVuc2lvbnMsIGNvbm5lY3REaXN0YW5jZSwgcHVsc2VOb2RlcywgZW5hYmxlR2xvdywgZGF0YVRyYW5zZmVyRWZmZWN0LCBjcmVhdGVEYXRhUGFja2V0XSk7XHJcbiAgXHJcbiAgLy8gTWF0cml4IGNvZGUgcmFpbiBhbmltYXRpb25cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFpc0luaXRpYWxpemVkIHx8ICFtYXRyaXhFZmZlY3QgfHwgIW1hdHJpeENhbnZhc1JlZi5jdXJyZW50IHx8IGRpbWVuc2lvbnMud2lkdGggPD0gMCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCBjYW52YXMgPSBtYXRyaXhDYW52YXNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRydWUgfSk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xyXG4gICAgICAvLyBBcHBseSBhIHNlbWktdHJhbnNwYXJlbnQgY2xlYXIgZm9yIHRyYWlsaW5nIGVmZmVjdFxyXG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4wNSknO1xyXG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xyXG4gICAgICBcclxuICAgICAgLy8gVXBkYXRlIGZyYWdtZW50c1xyXG4gICAgICBjb25zdCBmcmFnbWVudHMgPSBjb2RlRnJhZ21lbnRzUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRGcmFnbWVudHM6IENvZGVGcmFnbWVudFtdID0gW107XHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZnJhZ21lbnRzW2ldO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFVwZGF0ZSBhZ2VcclxuICAgICAgICBjb25zdCB1cGRhdGVkQWdlID0gZnJhZ21lbnQuYWdlICsgMTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBleHBpcmVkXHJcbiAgICAgICAgaWYgKHVwZGF0ZWRBZ2UgPiBmcmFnbWVudC5saWZlc3Bhbikge1xyXG4gICAgICAgICAgLy8gSW5zdGVhZCBvZiBjcmVhdGluZyBuZXcgZnJhZ21lbnRzIGhlcmUsIHdlJ2xsIG1haW50YWluIGNvdW50IGxhdGVyXHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIGJhc2VkIG9uIGZsb3cgZGlyZWN0aW9uXHJcbiAgICAgICAgbGV0IHVwZGF0ZWRZID0gZnJhZ21lbnQueTtcclxuICAgICAgICBpZiAoZmxvd0RpcmVjdGlvbiA9PT0gJ3VwJykge1xyXG4gICAgICAgICAgdXBkYXRlZFkgLT0gZnJhZ21lbnQuc3BlZWQ7XHJcbiAgICAgICAgfSBlbHNlIGlmIChmbG93RGlyZWN0aW9uID09PSAnZG93bicpIHtcclxuICAgICAgICAgIHVwZGF0ZWRZICs9IGZyYWdtZW50LnNwZWVkO1xyXG4gICAgICAgIH0gZWxzZSB7IC8vIHJhbmRvbVxyXG4gICAgICAgICAgdXBkYXRlZFkgKz0gKE1hdGgucmFuZG9tKCkgPiAwLjUgPyAxIDogLTEpICogZnJhZ21lbnQuc3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNraXAgaWYgb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgIGlmICh1cGRhdGVkWSA8IC0yMCB8fCB1cGRhdGVkWSA+IGRpbWVuc2lvbnMuaGVpZ2h0ICsgMjApIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDYWxjdWxhdGUgb3BhY2l0eSBiYXNlZCBvbiBsaWZlY3ljbGVcclxuICAgICAgICBjb25zdCBsaWZlY3ljbGVSYXRpbyA9IHVwZGF0ZWRBZ2UgLyBmcmFnbWVudC5saWZlc3BhbjtcclxuICAgICAgICBsZXQgb3BhY2l0eSA9IGZyYWdtZW50Lm9wYWNpdHk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKGxpZmVjeWNsZVJhdGlvIDwgMC4yKSB7XHJcbiAgICAgICAgICAvLyBGYWRlIGluXHJcbiAgICAgICAgICBvcGFjaXR5ICo9IGxpZmVjeWNsZVJhdGlvICogNTtcclxuICAgICAgICB9IGVsc2UgaWYgKGxpZmVjeWNsZVJhdGlvID4gMC44KSB7XHJcbiAgICAgICAgICAvLyBGYWRlIG91dFxyXG4gICAgICAgICAgb3BhY2l0eSAqPSAoMSAtIChsaWZlY3ljbGVSYXRpbyAtIDAuOCkgKiA1KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRHJhdyBjaGFyYWN0ZXJcclxuICAgICAgICBjdHguZm9udCA9ICcxNHB4IFwiSmV0QnJhaW5zIE1vbm9cIiwgbW9ub3NwYWNlJztcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb2xvciBiYXNlZCBvbiB0aGVtZSBvciBtdWx0aS1jb2xvclxyXG4gICAgICAgIGlmIChjb2xvclNjaGVtZSA9PT0gJ211bHRpJykge1xyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGBoc2woJHsoZnJhZ21lbnQueCAqIDM2MCAvIGRpbWVuc2lvbnMud2lkdGgpICUgMzYwfSwgMTAwJSwgNTAlLCAke29wYWNpdHl9KWA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBgJHt0aGVtZUNvbG9yc1tjb2xvclNjaGVtZV0ucHJpbWFyeX0ke01hdGguZmxvb3Iob3BhY2l0eSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyl9YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZyYWdtZW50LmNoYXIsIGZyYWdtZW50LngsIHVwZGF0ZWRZKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBSYW5kb21seSBjaGFuZ2UgY2hhcmFjdGVyXHJcbiAgICAgICAgY29uc3QgbmV3Q2hhciA9IE1hdGgucmFuZG9tKCkgPCAwLjA1XHJcbiAgICAgICAgICA/IG1hdHJpeENoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1hdHJpeENoYXJzLmxlbmd0aCldXHJcbiAgICAgICAgICA6IGZyYWdtZW50LmNoYXI7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gU2F2ZSB1cGRhdGVkIGZyYWdtZW50XHJcbiAgICAgICAgdXBkYXRlZEZyYWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgIC4uLmZyYWdtZW50LFxyXG4gICAgICAgICAgeTogdXBkYXRlZFksXHJcbiAgICAgICAgICBhZ2U6IHVwZGF0ZWRBZ2UsXHJcbiAgICAgICAgICBjaGFyOiBuZXdDaGFyXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIE1haW50YWluIGZyYWdtZW50IGNvdW50XHJcbiAgICAgIGNvbnN0IHRhcmdldENvdW50ID0gTWF0aC5taW4oTWF0aC5mbG9vcihjb2RlRnJhZ21lbnREZW5zaXR5ICogKGRpbWVuc2lvbnMud2lkdGggLyAxOTIwKSksIDEwMCk7XHJcbiAgICAgIFxyXG4gICAgICB3aGlsZSAodXBkYXRlZEZyYWdtZW50cy5sZW5ndGggPCB0YXJnZXRDb3VudCkge1xyXG4gICAgICAgIHVwZGF0ZWRGcmFnbWVudHMucHVzaChjcmVhdGVDb2RlRnJhZ21lbnQoZGltZW5zaW9ucy53aWR0aCkpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb2RlRnJhZ21lbnRzUmVmLmN1cnJlbnQgPSB1cGRhdGVkRnJhZ21lbnRzO1xyXG4gICAgICBtYXRyaXhBbmltYXRpb25SZWYuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICAgIH07XHJcbiAgICBcclxuICAgIGFuaW1hdGUoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgaWYgKG1hdHJpeEFuaW1hdGlvblJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUobWF0cml4QW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIG1hdHJpeEFuaW1hdGlvblJlZi5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbaXNJbml0aWFsaXplZCwgbWF0cml4RWZmZWN0LCBkaW1lbnNpb25zLCBjb2xvclNjaGVtZSwgY29kZUZyYWdtZW50RGVuc2l0eSwgZmxvd0RpcmVjdGlvbiwgY3JlYXRlQ29kZUZyYWdtZW50LCB0aGVtZUNvbG9ycywgbWF0cml4Q2hhcnNdKTtcclxuICBcclxuICAvLyBEYXRhIHBhY2tldHMgYW5pbWF0aW9uXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmICghaXNJbml0aWFsaXplZCB8fCAhZGF0YVRyYW5zZmVyRWZmZWN0IHx8ICFkYXRhQ2FudmFzUmVmLmN1cnJlbnQgfHwgZGltZW5zaW9ucy53aWR0aCA8PSAwKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRhdGFDYW52YXNSZWYuY3VycmVudDtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcsIHsgYWxwaGE6IHRydWUgfSk7XHJcbiAgICBpZiAoIWN0eCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCBhbmltYXRlID0gKCkgPT4ge1xyXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KTtcclxuICAgICAgXHJcbiAgICAgIC8vIFVwZGF0ZSBkYXRhIHBhY2tldHNcclxuICAgICAgY29uc3QgcGFja2V0cyA9IGRhdGFQYWNrZXRzUmVmLmN1cnJlbnQ7XHJcbiAgICAgIGNvbnN0IHVwZGF0ZWRQYWNrZXRzOiBEYXRhUGFja2V0W10gPSBbXTtcclxuICAgICAgXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFja2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gR2V0IHNvdXJjZSBhbmQgdGFyZ2V0IHBhcnRpY2xlc1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHBhcnRpY2xlc1JlZi5jdXJyZW50W3BhY2tldC5zb3VyY2VJbmRleF07XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gcGFydGljbGVzUmVmLmN1cnJlbnRbcGFja2V0LnRhcmdldEluZGV4XTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIXNvdXJjZSB8fCAhdGFyZ2V0KSBjb250aW51ZTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3NcclxuICAgICAgICBjb25zdCB1cGRhdGVkUHJvZ3Jlc3MgPSBwYWNrZXQucHJvZ3Jlc3MgKyBwYWNrZXQuc3BlZWQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUmVtb3ZlIGlmIGNvbXBsZXRlXHJcbiAgICAgICAgaWYgKHVwZGF0ZWRQcm9ncmVzcyA+PSAxKSB7XHJcbiAgICAgICAgICAvLyBSZXNldCBkYXRhIHRyYW5zZmVyIHN0YXRlIGZvciBzb3VyY2VcclxuICAgICAgICAgIGlmIChzb3VyY2UuZGF0YVRyYW5zZmVyKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5kYXRhVHJhbnNmZXIuYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIHVzaW5nIGN1YmljIGJlemllciBjdXJ2ZSBmb3IgYXJjIGVmZmVjdFxyXG4gICAgICAgIGNvbnN0IHQgPSB1cGRhdGVkUHJvZ3Jlc3M7XHJcbiAgICAgICAgY29uc3QgeDEgPSBzb3VyY2UueDtcclxuICAgICAgICBjb25zdCB5MSA9IHNvdXJjZS55O1xyXG4gICAgICAgIGNvbnN0IHgyID0gdGFyZ2V0Lng7XHJcbiAgICAgICAgY29uc3QgeTIgPSB0YXJnZXQueTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBDb250cm9sIHBvaW50IG9mZnNldFxyXG4gICAgICAgIGNvbnN0IGNwT2Zmc2V0WCA9ICh4MiAtIHgxKSAqIDAuNSAtICh5MiAtIHkxKSAqIDAuNTtcclxuICAgICAgICBjb25zdCBjcE9mZnNldFkgPSAoeTIgLSB5MSkgKiAwLjUgKyAoeDIgLSB4MSkgKiAwLjU7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ29udHJvbCBwb2ludHNcclxuICAgICAgICBjb25zdCBjcFggPSAoeDEgKyB4MikgLyAyICsgY3BPZmZzZXRYICogMC4zO1xyXG4gICAgICAgIGNvbnN0IGNwWSA9ICh5MSArIHkyKSAvIDIgKyBjcE9mZnNldFkgKiAwLjM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gUXVhZHJhdGljIGJlemllciBmb3JtdWxhXHJcbiAgICAgICAgY29uc3QgeCA9ICgxIC0gdCkgKiAoMSAtIHQpICogeDEgKyAyICogKDEgLSB0KSAqIHQgKiBjcFggKyB0ICogdCAqIHgyO1xyXG4gICAgICAgIGNvbnN0IHkgPSAoMSAtIHQpICogKDEgLSB0KSAqIHkxICsgMiAqICgxIC0gdCkgKiB0ICogY3BZICsgdCAqIHQgKiB5MjtcclxuICAgICAgICBcclxuICAgICAgICAvLyBEcmF3IHBhY2tldCB3aXRoIGdsb3cgZWZmZWN0XHJcbiAgICAgICAgaWYgKGVuYWJsZUdsb3cpIHtcclxuICAgICAgICAgIGNvbnN0IGdsb3dHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcclxuICAgICAgICAgICAgeCwgeSwgMCxcclxuICAgICAgICAgICAgeCwgeSwgcGFja2V0LnNpemUgKiA1XHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBnbG93R3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsIGAke3BhY2tldC5jb2xvcn04MGApO1xyXG4gICAgICAgICAgZ2xvd0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCBgJHtwYWNrZXQuY29sb3J9MDBgKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdsb3dHcmFkaWVudDtcclxuICAgICAgICAgIGN0eC5hcmMoeCwgeSwgcGFja2V0LnNpemUgKiA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBEcmF3IHBhY2tldCBjb3JlXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBwYWNrZXQuY29sb3I7XHJcbiAgICAgICAgY3R4LmFyYyh4LCB5LCBwYWNrZXQuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIG1vdGlvbiBibHVyIHRyYWlsXHJcbiAgICAgICAgY29uc3QgdHJhaWxMZW5ndGggPSAzO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAxOyBqIDw9IHRyYWlsTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IHRyYWlsVCA9IE1hdGgubWF4KDAsIHQgLSBqICogMC4wMyk7XHJcbiAgICAgICAgICBjb25zdCB0cmFpbFggPSAoMSAtIHRyYWlsVCkgKiAoMSAtIHRyYWlsVCkgKiB4MSArIDIgKiAoMSAtIHRyYWlsVCkgKiB0cmFpbFQgKiBjcFggKyB0cmFpbFQgKiB0cmFpbFQgKiB4MjtcclxuICAgICAgICAgIGNvbnN0IHRyYWlsWSA9ICgxIC0gdHJhaWxUKSAqICgxIC0gdHJhaWxUKSAqIHkxICsgMiAqICgxIC0gdHJhaWxUKSAqIHRyYWlsVCAqIGNwWSArIHRyYWlsVCAqIHRyYWlsVCAqIHkyO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gYCR7cGFja2V0LmNvbG9yfSR7TWF0aC5mbG9vcigoMC43IC0gaiAqIDAuMikgKiAyNTUpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpfWA7XHJcbiAgICAgICAgICBjdHguYXJjKHRyYWlsWCwgdHJhaWxZLCBwYWNrZXQuc2l6ZSAqICgxIC0gaiAqIDAuMiksIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNhdmUgdXBkYXRlZCBwYWNrZXRcclxuICAgICAgICB1cGRhdGVkUGFja2V0cy5wdXNoKHtcclxuICAgICAgICAgIC4uLnBhY2tldCxcclxuICAgICAgICAgIHByb2dyZXNzOiB1cGRhdGVkUHJvZ3Jlc3NcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgZGF0YVBhY2tldHNSZWYuY3VycmVudCA9IHVwZGF0ZWRQYWNrZXRzO1xyXG4gICAgICBkYXRhQW5pbWF0aW9uUmVmLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XHJcbiAgICB9O1xyXG4gICAgXHJcbiAgICBhbmltYXRlKCk7XHJcbiAgICBcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGlmIChkYXRhQW5pbWF0aW9uUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShkYXRhQW5pbWF0aW9uUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGRhdGFBbmltYXRpb25SZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfSwgW2lzSW5pdGlhbGl6ZWQsIGRhdGFUcmFuc2ZlckVmZmVjdCwgZGltZW5zaW9ucywgZW5hYmxlR2xvd10pO1xyXG4gIFxyXG4gIC8vIENsZWFudXAgYWxsIGFuaW1hdGlvbnMgb24gdW5tb3VudFxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBbbWFpbkFuaW1hdGlvblJlZiwgbWF0cml4QW5pbWF0aW9uUmVmLCBkYXRhQW5pbWF0aW9uUmVmXS5mb3JFYWNoKHJlZiA9PiB7XHJcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyZWYuY3VycmVudCk7XHJcbiAgICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSwgW10pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBcclxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XHJcbiAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLmNvbnRhaW5lcn0gJHtpc0xvYWRlZCA/IHN0eWxlcy5hY3RpdmUgOiAnJ30gJHtzdHlsZXNbY29sb3JTY2hlbWVdfWB9XHJcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIC8vIEhpZGRlbiBmcm9tIHNjcmVlbiByZWFkZXJzIGFzIHRoaXMgaXMgZGVjb3JhdGl2ZVxyXG4gICAgPlxyXG4gICAgICB7LyogTWFpbiBjYW52YXMgZm9yIHBhcnRpY2xlcyBhbmQgY29ubmVjdGlvbnMgKi99XHJcbiAgICAgIDxjYW52YXMgXHJcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9IFxyXG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNhbnZhc31cclxuICAgICAgICB3aWR0aD17ZGltZW5zaW9ucy53aWR0aH0gXHJcbiAgICAgICAgaGVpZ2h0PXtkaW1lbnNpb25zLmhlaWdodH1cclxuICAgICAgLz5cclxuICAgICAgXHJcbiAgICAgIHsvKiBDYW52YXMgZm9yIG1hdHJpeCBjb2RlIGVmZmVjdCAqL31cclxuICAgICAge21hdHJpeEVmZmVjdCAmJiAoXHJcbiAgICAgICAgPGNhbnZhcyBcclxuICAgICAgICAgIHJlZj17bWF0cml4Q2FudmFzUmVmfSBcclxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7c3R5bGVzLmNhbnZhc30gJHtzdHlsZXMubWF0cml4Q2FudmFzfWB9XHJcbiAgICAgICAgICB3aWR0aD17ZGltZW5zaW9ucy53aWR0aH0gXHJcbiAgICAgICAgICBoZWlnaHQ9e2RpbWVuc2lvbnMuaGVpZ2h0fVxyXG4gICAgICAgIC8+XHJcbiAgICAgICl9XHJcbiAgICAgIFxyXG4gICAgICB7LyogQ2FudmFzIGZvciBkYXRhIHRyYW5zZmVyIGVmZmVjdCAqL31cclxuICAgICAge2RhdGFUcmFuc2ZlckVmZmVjdCAmJiAoXHJcbiAgICAgICAgPGNhbnZhcyBcclxuICAgICAgICAgIHJlZj17ZGF0YUNhbnZhc1JlZn0gXHJcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5jYW52YXN9ICR7c3R5bGVzLmRhdGFDYW52YXN9YH1cclxuICAgICAgICAgIHdpZHRoPXtkaW1lbnNpb25zLndpZHRofSBcclxuICAgICAgICAgIGhlaWdodD17ZGltZW5zaW9ucy5oZWlnaHR9XHJcbiAgICAgICAgLz5cclxuICAgICAgKX1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBOZXVyYWxQYXJ0aWNsZVN5c3RlbTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsInN0eWxlcyIsIk5ldXJhbFBhcnRpY2xlU3lzdGVtIiwiZGVuc2l0eSIsImludGVyYWN0aXZlIiwicmVhY3RUb0NsaWNrIiwiY29ubmVjdERpc3RhbmNlIiwiY29sb3JTY2hlbWUiLCJtYXRyaXhFZmZlY3QiLCJkYXRhVHJhbnNmZXJFZmZlY3QiLCJjb2RlRnJhZ21lbnREZW5zaXR5IiwiZmxvd0RpcmVjdGlvbiIsInB1bHNlTm9kZXMiLCJlbmFibGVHbG93IiwiY2FudmFzUmVmIiwibWF0cml4Q2FudmFzUmVmIiwiZGF0YUNhbnZhc1JlZiIsImNvbnRhaW5lclJlZiIsImRpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJpc0xvYWRlZCIsInNldElzTG9hZGVkIiwiaXNJbml0aWFsaXplZCIsInNldElzSW5pdGlhbGl6ZWQiLCJwYXJ0aWNsZXNSZWYiLCJkYXRhUGFja2V0c1JlZiIsImNvZGVGcmFnbWVudHNSZWYiLCJtb3VzZVJlZiIsIngiLCJ5IiwiYWN0aXZlIiwibGFzdENsaWNrUmVmIiwidGltZSIsIm1haW5BbmltYXRpb25SZWYiLCJtYXRyaXhBbmltYXRpb25SZWYiLCJkYXRhQW5pbWF0aW9uUmVmIiwibWF0cml4Q2hhcnMiLCJzdGFuZGFyZENoYXJzIiwic3BsaXQiLCJxdWFudHVtQ2hhcnMiLCJmaWx0ZXIiLCJfIiwiaSIsInRoZW1lQ29sb3JzIiwidGhlbWVzIiwiZ3JlZW4iLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwidGVydGlhcnkiLCJhY2NlbnQiLCJiYWNrZ3JvdW5kIiwiZGF0YSIsImJsdWUiLCJwdXJwbGUiLCJyZWQiLCJjeWFuIiwibXVsdGkiLCJ1cGRhdGVEaW1lbnNpb25zIiwiY3VycmVudCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0IiwicHJldkRpbWVuc2lvbnMiLCJyZXNpemVUaW1lciIsImhhbmRsZVJlc2l6ZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXRQYXJ0aWNsZUNvbG9yIiwiaXNOZXVyb24iLCJjb2xvcnMiLCJzY2hlbWVzIiwicmFuZG9tU2NoZW1lIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwic2NoZW1lQ29sb3JzIiwiZHByIiwiZGV2aWNlUGl4ZWxSYXRpbyIsInVwZGF0ZUNhbnZhcyIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJzY2FsZSIsImluaXRQYXJ0aWNsZXMiLCJpbml0Q29kZUZyYWdtZW50cyIsImxvYWRUaW1lciIsInNjYWxlRmFjdG9yIiwic2NhbGVkRGVuc2l0eSIsIm1heCIsImNvdW50IiwibWluIiwicGFydGljbGVzIiwicHVzaCIsInZ4IiwidnkiLCJyYWRpdXMiLCJjb2xvciIsIm9wYWNpdHkiLCJwdWxzZVJhdGUiLCJwdWxzZVBoYXNlIiwiUEkiLCJjb25uZWN0aW9ucyIsImRhdGFUcmFuc2ZlciIsInByb2dyZXNzIiwic3BlZWQiLCJ0YXJnZXROb2RlSW5kZXgiLCJ1bmRlZmluZWQiLCJmcmFnbWVudHMiLCJjcmVhdGVDb2RlRnJhZ21lbnQiLCJzdGFydFkiLCJmcmFnbWVudCIsImNoYXIiLCJsaWZlc3BhbiIsImFnZSIsImNyZWF0ZURhdGFQYWNrZXQiLCJzb3VyY2VJbmRleCIsInRhcmdldEluZGV4Iiwic291cmNlIiwidGFyZ2V0IiwicGFja2V0Iiwic2l6ZSIsImhhbmRsZU1vdXNlTW92ZSIsImUiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImxlZnQiLCJjbGllbnRZIiwidG9wIiwiaGFuZGxlTW91c2VMZWF2ZSIsImhhbmRsZUNsaWNrIiwibm93IiwiRGF0ZSIsImFkZFBhcnRpY2xlc0F0UG9pbnQiLCJhZGRDb2RlRnJhZ21lbnRzQXRQb2ludCIsImFuZ2xlIiwiY29zIiwic2luIiwiZnJhbWVDb3VudCIsImxhc3RUaW1lc3RhbXAiLCJhbmltYXRlIiwidGltZXN0YW1wIiwiZGVsdGFUaW1lIiwiY2xlYXJSZWN0Iiwic2hvdWxkQ29tcHV0ZUNvbm5lY3Rpb25zIiwiZm9yRWFjaCIsInAiLCJsZW4iLCJqIiwicDIiLCJkeCIsImR5IiwiZGlzdFNxdWFyZWQiLCJjb25uZWN0aW9uRGlzdGFuY2VTcXVhcmVkIiwibWF4RGlzdGFuY2UiLCJtYXhEaXN0YW5jZVNxdWFyZWQiLCJmb3JjZSIsInNxcnQiLCJhdGFuMiIsImF0dHJhY3Rpb25Gb3JjZSIsIm1heFNwZWVkIiwiZGlzcGxheVJhZGl1cyIsImN1cnJlbnRPcGFjaXR5IiwicHVsc2UiLCJkaXN0YW5jZSIsImxpbmVPcGFjaXR5IiwiZ3JhZGllbnQiLCJjcmVhdGVMaW5lYXJHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsInJlcGxhY2UiLCJiZWdpblBhdGgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImdsb3dTaXplIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJmaWxsU3R5bGUiLCJhcmMiLCJmaWxsIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJhbHBoYSIsImZpbGxSZWN0IiwidXBkYXRlZEZyYWdtZW50cyIsInVwZGF0ZWRBZ2UiLCJ1cGRhdGVkWSIsImxpZmVjeWNsZVJhdGlvIiwiZm9udCIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJmaWxsVGV4dCIsIm5ld0NoYXIiLCJ0YXJnZXRDb3VudCIsInBhY2tldHMiLCJ1cGRhdGVkUGFja2V0cyIsInVwZGF0ZWRQcm9ncmVzcyIsInQiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImNwT2Zmc2V0WCIsImNwT2Zmc2V0WSIsImNwWCIsImNwWSIsImdsb3dHcmFkaWVudCIsInRyYWlsTGVuZ3RoIiwidHJhaWxUIiwidHJhaWxYIiwidHJhaWxZIiwicmVmIiwiZGl2IiwiY2xhc3NOYW1lIiwiY29udGFpbmVyIiwiYXJpYS1oaWRkZW4iLCJtYXRyaXhDYW52YXMiLCJkYXRhQ2FudmFzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/NeuralParticleSystem/index.ts":
/*!******************************************************!*\
  !*** ./src/components/NeuralParticleSystem/index.ts ***!
  \******************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _NeuralParticleSystem__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _NeuralParticleSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NeuralParticleSystem */ \"(app-pages-browser)/./src/components/NeuralParticleSystem/NeuralParticleSystem.tsx\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2luZGV4LnRzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL05ldXJhbFBhcnRpY2xlU3lzdGVtL2luZGV4LnRzP2VkYzMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCB9IGZyb20gJy4vTmV1cmFsUGFydGljbGVTeXN0ZW0nO1xyXG5cclxuZXhwb3J0IHR5cGUge1xyXG4gIE5ldXJhbFBhcnRpY2xlU3lzdGVtUHJvcHMsXHJcbiAgTmV1cmFsUGFydGljbGUsXHJcbiAgRGF0YVBhY2tldCxcclxuICBDb2RlRnJhZ21lbnRcclxufSBmcm9tICcuL05ldXJhbFBhcnRpY2xlU3lzdGVtJzsiXSwibmFtZXMiOlsiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/NeuralParticleSystem/index.ts\n"));

/***/ })

}]);